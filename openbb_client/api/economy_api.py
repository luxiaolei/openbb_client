# coding: utf-8

"""
    OpenBB Platform API

    Investment research for everyone, anywhere.

    The version of the OpenAPI document: 1
    Contact: hello@openbb.co
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, Optional, Union
from typing_extensions import Annotated
from openbb_client.models.ob_bject_available_indicators import OBBjectAvailableIndicators
from openbb_client.models.ob_bject_balance_of_payments import OBBjectBalanceOfPayments
from openbb_client.models.ob_bject_bls_search import OBBjectBlsSearch
from openbb_client.models.ob_bject_bls_series import OBBjectBlsSeries
from openbb_client.models.ob_bject_central_bank_holdings import OBBjectCentralBankHoldings
from openbb_client.models.ob_bject_composite_leading_indicator import OBBjectCompositeLeadingIndicator
from openbb_client.models.ob_bject_consumer_price_index import OBBjectConsumerPriceIndex
from openbb_client.models.ob_bject_country_interest_rates import OBBjectCountryInterestRates
from openbb_client.models.ob_bject_country_profile import OBBjectCountryProfile
from openbb_client.models.ob_bject_direction_of_trade import OBBjectDirectionOfTrade
from openbb_client.models.ob_bject_economic_calendar import OBBjectEconomicCalendar
from openbb_client.models.ob_bject_economic_indicators import OBBjectEconomicIndicators
from openbb_client.models.ob_bject_export_destinations import OBBjectExportDestinations
from openbb_client.models.ob_bject_fred_regional import OBBjectFredRegional
from openbb_client.models.ob_bject_fred_release_table import OBBjectFredReleaseTable
from openbb_client.models.ob_bject_fred_search import OBBjectFredSearch
from openbb_client.models.ob_bject_fred_series import OBBjectFredSeries
from openbb_client.models.ob_bject_gdp_forecast import OBBjectGdpForecast
from openbb_client.models.ob_bject_gdp_nominal import OBBjectGdpNominal
from openbb_client.models.ob_bject_gdp_real import OBBjectGdpReal
from openbb_client.models.ob_bject_house_price_index import OBBjectHousePriceIndex
from openbb_client.models.ob_bject_immediate_interest_rate import OBBjectImmediateInterestRate
from openbb_client.models.ob_bject_ltir import OBBjectLTIR
from openbb_client.models.ob_bject_manufacturing_outlook_texas import OBBjectManufacturingOutlookTexas
from openbb_client.models.ob_bject_money_measures import OBBjectMoneyMeasures
from openbb_client.models.ob_bject_non_farm_payrolls import OBBjectNonFarmPayrolls
from openbb_client.models.ob_bject_personal_consumption_expenditures import OBBjectPersonalConsumptionExpenditures
from openbb_client.models.ob_bject_port_volume import OBBjectPortVolume
from openbb_client.models.ob_bject_primary_dealer_fails import OBBjectPrimaryDealerFails
from openbb_client.models.ob_bject_primary_dealer_positioning import OBBjectPrimaryDealerPositioning
from openbb_client.models.ob_bject_retail_prices import OBBjectRetailPrices
from openbb_client.models.ob_bject_risk_premium import OBBjectRiskPremium
from openbb_client.models.ob_bject_stir import OBBjectSTIR
from openbb_client.models.ob_bject_senior_loan_officer_survey import OBBjectSeniorLoanOfficerSurvey
from openbb_client.models.ob_bject_share_price_index import OBBjectSharePriceIndex
from openbb_client.models.ob_bject_survey_of_economic_conditions_chicago import OBBjectSurveyOfEconomicConditionsChicago
from openbb_client.models.ob_bject_unemployment import OBBjectUnemployment
from openbb_client.models.ob_bject_university_of_michigan import OBBjectUniversityOfMichigan

from openbb_client.api_client import ApiClient, RequestSerialized
from openbb_client.api_response import ApiResponse
from openbb_client.rest import RESTResponseType


class EconomyApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def economy_available_indicators(
        self,
        provider: StrictStr,
        use_cache: Annotated[Optional[StrictBool], Field(description="Whether to use cache or not, by default is True The cache of indicator symbols will persist for one week. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectAvailableIndicators:
        """Available Indicators

        Get the available economic indicators for a provider.

        :param provider: (required)
        :type provider: str
        :param use_cache: Whether to use cache or not, by default is True The cache of indicator symbols will persist for one week. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_available_indicators_serialize(
            provider=provider,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectAvailableIndicators",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_available_indicators_with_http_info(
        self,
        provider: StrictStr,
        use_cache: Annotated[Optional[StrictBool], Field(description="Whether to use cache or not, by default is True The cache of indicator symbols will persist for one week. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectAvailableIndicators]:
        """Available Indicators

        Get the available economic indicators for a provider.

        :param provider: (required)
        :type provider: str
        :param use_cache: Whether to use cache or not, by default is True The cache of indicator symbols will persist for one week. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_available_indicators_serialize(
            provider=provider,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectAvailableIndicators",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_available_indicators_without_preload_content(
        self,
        provider: StrictStr,
        use_cache: Annotated[Optional[StrictBool], Field(description="Whether to use cache or not, by default is True The cache of indicator symbols will persist for one week. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Available Indicators

        Get the available economic indicators for a provider.

        :param provider: (required)
        :type provider: str
        :param use_cache: Whether to use cache or not, by default is True The cache of indicator symbols will persist for one week. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_available_indicators_serialize(
            provider=provider,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectAvailableIndicators",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_available_indicators_serialize(
        self,
        provider,
        use_cache,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if use_cache is not None:
            
            _query_params.append(('use_cache', use_cache))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/available_indicators',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_balance_of_payments(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Enter as a 3-letter ISO country code, default is USA. (provider: fred)")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format. (provider: fred)")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectBalanceOfPayments:
        """Balance Of Payments

        Balance of Payments Reports.

        :param provider:
        :type provider: str
        :param country: The country to get data. Enter as a 3-letter ISO country code, default is USA. (provider: fred)
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format. (provider: fred)
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format. (provider: fred)
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_balance_of_payments_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBalanceOfPayments",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_balance_of_payments_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Enter as a 3-letter ISO country code, default is USA. (provider: fred)")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format. (provider: fred)")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectBalanceOfPayments]:
        """Balance Of Payments

        Balance of Payments Reports.

        :param provider:
        :type provider: str
        :param country: The country to get data. Enter as a 3-letter ISO country code, default is USA. (provider: fred)
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format. (provider: fred)
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format. (provider: fred)
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_balance_of_payments_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBalanceOfPayments",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_balance_of_payments_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Enter as a 3-letter ISO country code, default is USA. (provider: fred)")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format. (provider: fred)")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Balance Of Payments

        Balance of Payments Reports.

        :param provider:
        :type provider: str
        :param country: The country to get data. Enter as a 3-letter ISO country code, default is USA. (provider: fred)
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format. (provider: fred)
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format. (provider: fred)
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_balance_of_payments_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBalanceOfPayments",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_balance_of_payments_serialize(
        self,
        provider,
        country,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/balance_of_payments',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_calendar(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country of the event. Multiple comma separated items allowed. (provider: tradingeconomics)")] = None,
        importance: Annotated[Optional[StrictStr], Field(description="Importance of the event. (provider: tradingeconomics)")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Grouping of events. (provider: tradingeconomics)")] = None,
        calendar_id: Annotated[Optional[Any], Field(description="Get events by TradingEconomics Calendar ID. Multiple comma separated items allowed. (provider: tradingeconomics)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectEconomicCalendar:
        """Calendar

        Get the upcoming, or historical, economic calendar of global events.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country of the event. Multiple comma separated items allowed. (provider: tradingeconomics)
        :type country: str
        :param importance: Importance of the event. (provider: tradingeconomics)
        :type importance: str
        :param group: Grouping of events. (provider: tradingeconomics)
        :type group: str
        :param calendar_id: Get events by TradingEconomics Calendar ID. Multiple comma separated items allowed. (provider: tradingeconomics)
        :type calendar_id: Tradingeconomics
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_calendar_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            importance=importance,
            group=group,
            calendar_id=calendar_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEconomicCalendar",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_calendar_with_http_info(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country of the event. Multiple comma separated items allowed. (provider: tradingeconomics)")] = None,
        importance: Annotated[Optional[StrictStr], Field(description="Importance of the event. (provider: tradingeconomics)")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Grouping of events. (provider: tradingeconomics)")] = None,
        calendar_id: Annotated[Optional[Any], Field(description="Get events by TradingEconomics Calendar ID. Multiple comma separated items allowed. (provider: tradingeconomics)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectEconomicCalendar]:
        """Calendar

        Get the upcoming, or historical, economic calendar of global events.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country of the event. Multiple comma separated items allowed. (provider: tradingeconomics)
        :type country: str
        :param importance: Importance of the event. (provider: tradingeconomics)
        :type importance: str
        :param group: Grouping of events. (provider: tradingeconomics)
        :type group: str
        :param calendar_id: Get events by TradingEconomics Calendar ID. Multiple comma separated items allowed. (provider: tradingeconomics)
        :type calendar_id: Tradingeconomics
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_calendar_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            importance=importance,
            group=group,
            calendar_id=calendar_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEconomicCalendar",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_calendar_without_preload_content(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country of the event. Multiple comma separated items allowed. (provider: tradingeconomics)")] = None,
        importance: Annotated[Optional[StrictStr], Field(description="Importance of the event. (provider: tradingeconomics)")] = None,
        group: Annotated[Optional[StrictStr], Field(description="Grouping of events. (provider: tradingeconomics)")] = None,
        calendar_id: Annotated[Optional[Any], Field(description="Get events by TradingEconomics Calendar ID. Multiple comma separated items allowed. (provider: tradingeconomics)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Calendar

        Get the upcoming, or historical, economic calendar of global events.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country of the event. Multiple comma separated items allowed. (provider: tradingeconomics)
        :type country: str
        :param importance: Importance of the event. (provider: tradingeconomics)
        :type importance: str
        :param group: Grouping of events. (provider: tradingeconomics)
        :type group: str
        :param calendar_id: Get events by TradingEconomics Calendar ID. Multiple comma separated items allowed. (provider: tradingeconomics)
        :type calendar_id: Tradingeconomics
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_calendar_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            importance=importance,
            group=group,
            calendar_id=calendar_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEconomicCalendar",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_calendar_serialize(
        self,
        provider,
        start_date,
        end_date,
        country,
        importance,
        group,
        calendar_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if importance is not None:
            
            _query_params.append(('importance', importance))
            
        if group is not None:
            
            _query_params.append(('group', group))
            
        if calendar_id is not None:
            
            _query_params.append(('calendar_id', calendar_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/calendar',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_central_bank_holdings(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[date], Field(description="A specific date to get data for.")] = None,
        holding_type: Annotated[Optional[StrictStr], Field(description="Type of holdings to return. (provider: federal_reserve)")] = None,
        summary: Annotated[Optional[StrictBool], Field(description="If True, returns historical weekly summary by holding type. This parameter takes priority over other parameters. (provider: federal_reserve)")] = None,
        cusip: Annotated[Optional[StrictStr], Field(description=" Multiple comma separated items allowed.")] = None,
        wam: Annotated[Optional[StrictBool], Field(description="If True, returns weighted average maturity aggregated by agency or treasury securities. This parameter takes priority over `holding_type`, `cusip`, and `monthly`. (provider: federal_reserve)")] = None,
        monthly: Annotated[Optional[StrictBool], Field(description="If True, returns historical data for all Treasury securities at a monthly interval. This parameter takes priority over other parameters, except `wam`. Only valid when `holding_type` is set to: 'all_treasury', 'bills', 'notesbonds', 'frn', 'tips'. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectCentralBankHoldings:
        """Central Bank Holdings

        Get the balance sheet holdings of a central bank.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for.
        :type var_date: date
        :param holding_type: Type of holdings to return. (provider: federal_reserve)
        :type holding_type: str
        :param summary: If True, returns historical weekly summary by holding type. This parameter takes priority over other parameters. (provider: federal_reserve)
        :type summary: bool
        :param cusip:  Multiple comma separated items allowed.
        :type cusip: str
        :param wam: If True, returns weighted average maturity aggregated by agency or treasury securities. This parameter takes priority over `holding_type`, `cusip`, and `monthly`. (provider: federal_reserve)
        :type wam: bool
        :param monthly: If True, returns historical data for all Treasury securities at a monthly interval. This parameter takes priority over other parameters, except `wam`. Only valid when `holding_type` is set to: 'all_treasury', 'bills', 'notesbonds', 'frn', 'tips'. (provider: federal_reserve)
        :type monthly: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_central_bank_holdings_serialize(
            provider=provider,
            var_date=var_date,
            holding_type=holding_type,
            summary=summary,
            cusip=cusip,
            wam=wam,
            monthly=monthly,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCentralBankHoldings",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_central_bank_holdings_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[date], Field(description="A specific date to get data for.")] = None,
        holding_type: Annotated[Optional[StrictStr], Field(description="Type of holdings to return. (provider: federal_reserve)")] = None,
        summary: Annotated[Optional[StrictBool], Field(description="If True, returns historical weekly summary by holding type. This parameter takes priority over other parameters. (provider: federal_reserve)")] = None,
        cusip: Annotated[Optional[StrictStr], Field(description=" Multiple comma separated items allowed.")] = None,
        wam: Annotated[Optional[StrictBool], Field(description="If True, returns weighted average maturity aggregated by agency or treasury securities. This parameter takes priority over `holding_type`, `cusip`, and `monthly`. (provider: federal_reserve)")] = None,
        monthly: Annotated[Optional[StrictBool], Field(description="If True, returns historical data for all Treasury securities at a monthly interval. This parameter takes priority over other parameters, except `wam`. Only valid when `holding_type` is set to: 'all_treasury', 'bills', 'notesbonds', 'frn', 'tips'. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectCentralBankHoldings]:
        """Central Bank Holdings

        Get the balance sheet holdings of a central bank.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for.
        :type var_date: date
        :param holding_type: Type of holdings to return. (provider: federal_reserve)
        :type holding_type: str
        :param summary: If True, returns historical weekly summary by holding type. This parameter takes priority over other parameters. (provider: federal_reserve)
        :type summary: bool
        :param cusip:  Multiple comma separated items allowed.
        :type cusip: str
        :param wam: If True, returns weighted average maturity aggregated by agency or treasury securities. This parameter takes priority over `holding_type`, `cusip`, and `monthly`. (provider: federal_reserve)
        :type wam: bool
        :param monthly: If True, returns historical data for all Treasury securities at a monthly interval. This parameter takes priority over other parameters, except `wam`. Only valid when `holding_type` is set to: 'all_treasury', 'bills', 'notesbonds', 'frn', 'tips'. (provider: federal_reserve)
        :type monthly: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_central_bank_holdings_serialize(
            provider=provider,
            var_date=var_date,
            holding_type=holding_type,
            summary=summary,
            cusip=cusip,
            wam=wam,
            monthly=monthly,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCentralBankHoldings",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_central_bank_holdings_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[date], Field(description="A specific date to get data for.")] = None,
        holding_type: Annotated[Optional[StrictStr], Field(description="Type of holdings to return. (provider: federal_reserve)")] = None,
        summary: Annotated[Optional[StrictBool], Field(description="If True, returns historical weekly summary by holding type. This parameter takes priority over other parameters. (provider: federal_reserve)")] = None,
        cusip: Annotated[Optional[StrictStr], Field(description=" Multiple comma separated items allowed.")] = None,
        wam: Annotated[Optional[StrictBool], Field(description="If True, returns weighted average maturity aggregated by agency or treasury securities. This parameter takes priority over `holding_type`, `cusip`, and `monthly`. (provider: federal_reserve)")] = None,
        monthly: Annotated[Optional[StrictBool], Field(description="If True, returns historical data for all Treasury securities at a monthly interval. This parameter takes priority over other parameters, except `wam`. Only valid when `holding_type` is set to: 'all_treasury', 'bills', 'notesbonds', 'frn', 'tips'. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Central Bank Holdings

        Get the balance sheet holdings of a central bank.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for.
        :type var_date: date
        :param holding_type: Type of holdings to return. (provider: federal_reserve)
        :type holding_type: str
        :param summary: If True, returns historical weekly summary by holding type. This parameter takes priority over other parameters. (provider: federal_reserve)
        :type summary: bool
        :param cusip:  Multiple comma separated items allowed.
        :type cusip: str
        :param wam: If True, returns weighted average maturity aggregated by agency or treasury securities. This parameter takes priority over `holding_type`, `cusip`, and `monthly`. (provider: federal_reserve)
        :type wam: bool
        :param monthly: If True, returns historical data for all Treasury securities at a monthly interval. This parameter takes priority over other parameters, except `wam`. Only valid when `holding_type` is set to: 'all_treasury', 'bills', 'notesbonds', 'frn', 'tips'. (provider: federal_reserve)
        :type monthly: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_central_bank_holdings_serialize(
            provider=provider,
            var_date=var_date,
            holding_type=holding_type,
            summary=summary,
            cusip=cusip,
            wam=wam,
            monthly=monthly,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCentralBankHoldings",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_central_bank_holdings_serialize(
        self,
        provider,
        var_date,
        holding_type,
        summary,
        cusip,
        wam,
        monthly,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if var_date is not None:
            if isinstance(var_date, date):
                _query_params.append(
                    (
                        'date',
                        var_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date', var_date))
            
        if holding_type is not None:
            
            _query_params.append(('holding_type', holding_type))
            
        if summary is not None:
            
            _query_params.append(('summary', summary))
            
        if cusip is not None:
            
            _query_params.append(('cusip', cusip))
            
        if wam is not None:
            
            _query_params.append(('wam', wam))
            
        if monthly is not None:
            
            _query_params.append(('monthly', monthly))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/central_bank_holdings',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_composite_leading_indicator(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[Any], Field(description="Country to get the CLI for, default is G20. Multiple comma separated items allowed. (provider: oecd)")] = None,
        adjustment: Annotated[Optional[StrictStr], Field(description="Adjustment of the data, either 'amplitude' or 'normalized'. Default is amplitude. (provider: oecd)")] = None,
        growth_rate: Annotated[Optional[StrictBool], Field(description="Return the 1-year growth rate (%) of the CLI, default is False. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectCompositeLeadingIndicator:
        """Composite Leading Indicator

        Get the composite leading indicator (CLI).  It is designed to provide early signals of turning points in business cycles showing fluctuation of the economic activity around its long term potential level.  CLIs show short-term economic movements in qualitative rather than quantitative terms.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get the CLI for, default is G20. Multiple comma separated items allowed. (provider: oecd)
        :type country: Oecd
        :param adjustment: Adjustment of the data, either 'amplitude' or 'normalized'. Default is amplitude. (provider: oecd)
        :type adjustment: str
        :param growth_rate: Return the 1-year growth rate (%) of the CLI, default is False. (provider: oecd)
        :type growth_rate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_composite_leading_indicator_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            adjustment=adjustment,
            growth_rate=growth_rate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCompositeLeadingIndicator",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_composite_leading_indicator_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[Any], Field(description="Country to get the CLI for, default is G20. Multiple comma separated items allowed. (provider: oecd)")] = None,
        adjustment: Annotated[Optional[StrictStr], Field(description="Adjustment of the data, either 'amplitude' or 'normalized'. Default is amplitude. (provider: oecd)")] = None,
        growth_rate: Annotated[Optional[StrictBool], Field(description="Return the 1-year growth rate (%) of the CLI, default is False. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectCompositeLeadingIndicator]:
        """Composite Leading Indicator

        Get the composite leading indicator (CLI).  It is designed to provide early signals of turning points in business cycles showing fluctuation of the economic activity around its long term potential level.  CLIs show short-term economic movements in qualitative rather than quantitative terms.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get the CLI for, default is G20. Multiple comma separated items allowed. (provider: oecd)
        :type country: Oecd
        :param adjustment: Adjustment of the data, either 'amplitude' or 'normalized'. Default is amplitude. (provider: oecd)
        :type adjustment: str
        :param growth_rate: Return the 1-year growth rate (%) of the CLI, default is False. (provider: oecd)
        :type growth_rate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_composite_leading_indicator_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            adjustment=adjustment,
            growth_rate=growth_rate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCompositeLeadingIndicator",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_composite_leading_indicator_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[Any], Field(description="Country to get the CLI for, default is G20. Multiple comma separated items allowed. (provider: oecd)")] = None,
        adjustment: Annotated[Optional[StrictStr], Field(description="Adjustment of the data, either 'amplitude' or 'normalized'. Default is amplitude. (provider: oecd)")] = None,
        growth_rate: Annotated[Optional[StrictBool], Field(description="Return the 1-year growth rate (%) of the CLI, default is False. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Composite Leading Indicator

        Get the composite leading indicator (CLI).  It is designed to provide early signals of turning points in business cycles showing fluctuation of the economic activity around its long term potential level.  CLIs show short-term economic movements in qualitative rather than quantitative terms.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get the CLI for, default is G20. Multiple comma separated items allowed. (provider: oecd)
        :type country: Oecd
        :param adjustment: Adjustment of the data, either 'amplitude' or 'normalized'. Default is amplitude. (provider: oecd)
        :type adjustment: str
        :param growth_rate: Return the 1-year growth rate (%) of the CLI, default is False. (provider: oecd)
        :type growth_rate: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_composite_leading_indicator_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            adjustment=adjustment,
            growth_rate=growth_rate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCompositeLeadingIndicator",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_composite_leading_indicator_serialize(
        self,
        provider,
        start_date,
        end_date,
        country,
        adjustment,
        growth_rate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if adjustment is not None:
            
            _query_params.append(('adjustment', adjustment))
            
        if growth_rate is not None:
            
            _query_params.append(('growth_rate', growth_rate))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/composite_leading_indicator',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_country_profile(
        self,
        country: Annotated[StrictStr, Field(description="The country to get data. Multiple comma separated items allowed for provider(s): econdb.")],
        provider: Optional[StrictStr] = None,
        latest: Annotated[Optional[StrictBool], Field(description="If True, return only the latest data. If False, return all available data for each indicator. (provider: econdb)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day.Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectCountryProfile:
        """Country Profile

        Get a profile of country statistics and economic indicators.

        :param country: The country to get data. Multiple comma separated items allowed for provider(s): econdb. (required)
        :type country: str
        :param provider:
        :type provider: str
        :param latest: If True, return only the latest data. If False, return all available data for each indicator. (provider: econdb)
        :type latest: bool
        :param use_cache: If True, the request will be cached for one day.Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_country_profile_serialize(
            country=country,
            provider=provider,
            latest=latest,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCountryProfile",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_country_profile_with_http_info(
        self,
        country: Annotated[StrictStr, Field(description="The country to get data. Multiple comma separated items allowed for provider(s): econdb.")],
        provider: Optional[StrictStr] = None,
        latest: Annotated[Optional[StrictBool], Field(description="If True, return only the latest data. If False, return all available data for each indicator. (provider: econdb)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day.Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectCountryProfile]:
        """Country Profile

        Get a profile of country statistics and economic indicators.

        :param country: The country to get data. Multiple comma separated items allowed for provider(s): econdb. (required)
        :type country: str
        :param provider:
        :type provider: str
        :param latest: If True, return only the latest data. If False, return all available data for each indicator. (provider: econdb)
        :type latest: bool
        :param use_cache: If True, the request will be cached for one day.Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_country_profile_serialize(
            country=country,
            provider=provider,
            latest=latest,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCountryProfile",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_country_profile_without_preload_content(
        self,
        country: Annotated[StrictStr, Field(description="The country to get data. Multiple comma separated items allowed for provider(s): econdb.")],
        provider: Optional[StrictStr] = None,
        latest: Annotated[Optional[StrictBool], Field(description="If True, return only the latest data. If False, return all available data for each indicator. (provider: econdb)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day.Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Country Profile

        Get a profile of country statistics and economic indicators.

        :param country: The country to get data. Multiple comma separated items allowed for provider(s): econdb. (required)
        :type country: str
        :param provider:
        :type provider: str
        :param latest: If True, return only the latest data. If False, return all available data for each indicator. (provider: econdb)
        :type latest: bool
        :param use_cache: If True, the request will be cached for one day.Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_country_profile_serialize(
            country=country,
            provider=provider,
            latest=latest,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCountryProfile",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_country_profile_serialize(
        self,
        country,
        provider,
        latest,
        use_cache,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if latest is not None:
            
            _query_params.append(('latest', latest))
            
        if use_cache is not None:
            
            _query_params.append(('use_cache', use_cache))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/country_profile',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_cpi(
        self,
        provider: StrictStr,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): fred, oecd.")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        harmonized: Annotated[Optional[StrictBool], Field(description="If true, returns harmonized data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        expenditure: Annotated[Optional[StrictStr], Field(description="Expenditure component of CPI. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectConsumerPriceIndex:
        """Cpi

        Get Consumer Price Index (CPI).  Returns either the rescaled index value, or a rate of change (inflation).

        :param provider: (required)
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): fred, oecd.
        :type country: str
        :param transform: Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).
        :type transform: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param harmonized: If true, returns harmonized data.
        :type harmonized: bool
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param expenditure: Expenditure component of CPI. (provider: oecd)
        :type expenditure: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_cpi_serialize(
            provider=provider,
            country=country,
            transform=transform,
            frequency=frequency,
            harmonized=harmonized,
            start_date=start_date,
            end_date=end_date,
            expenditure=expenditure,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectConsumerPriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_cpi_with_http_info(
        self,
        provider: StrictStr,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): fred, oecd.")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        harmonized: Annotated[Optional[StrictBool], Field(description="If true, returns harmonized data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        expenditure: Annotated[Optional[StrictStr], Field(description="Expenditure component of CPI. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectConsumerPriceIndex]:
        """Cpi

        Get Consumer Price Index (CPI).  Returns either the rescaled index value, or a rate of change (inflation).

        :param provider: (required)
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): fred, oecd.
        :type country: str
        :param transform: Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).
        :type transform: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param harmonized: If true, returns harmonized data.
        :type harmonized: bool
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param expenditure: Expenditure component of CPI. (provider: oecd)
        :type expenditure: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_cpi_serialize(
            provider=provider,
            country=country,
            transform=transform,
            frequency=frequency,
            harmonized=harmonized,
            start_date=start_date,
            end_date=end_date,
            expenditure=expenditure,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectConsumerPriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_cpi_without_preload_content(
        self,
        provider: StrictStr,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): fred, oecd.")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        harmonized: Annotated[Optional[StrictBool], Field(description="If true, returns harmonized data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        expenditure: Annotated[Optional[StrictStr], Field(description="Expenditure component of CPI. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Cpi

        Get Consumer Price Index (CPI).  Returns either the rescaled index value, or a rate of change (inflation).

        :param provider: (required)
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): fred, oecd.
        :type country: str
        :param transform: Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).
        :type transform: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param harmonized: If true, returns harmonized data.
        :type harmonized: bool
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param expenditure: Expenditure component of CPI. (provider: oecd)
        :type expenditure: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_cpi_serialize(
            provider=provider,
            country=country,
            transform=transform,
            frequency=frequency,
            harmonized=harmonized,
            start_date=start_date,
            end_date=end_date,
            expenditure=expenditure,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectConsumerPriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_cpi_serialize(
        self,
        provider,
        country,
        transform,
        frequency,
        harmonized,
        start_date,
        end_date,
        expenditure,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if harmonized is not None:
            
            _query_params.append(('harmonized', harmonized))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if expenditure is not None:
            
            _query_params.append(('expenditure', expenditure))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/cpi',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_direction_of_trade(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. None is an equiavlent to 'all'. If 'all' is used, the counterpart field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.")] = None,
        counterpart: Annotated[Optional[StrictStr], Field(description="Counterpart country to the trade. None is an equiavlent to 'all'. If 'all' is used, the country field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="Trade direction. Use 'all' to get all data for this dimension.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectDirectionOfTrade:
        """Direction Of Trade

        Get Direction Of Trade Statistics from the IMF database.  The Direction of Trade Statistics (DOTS) presents the value of merchandise exports and imports disaggregated according to a country's primary trading partners. Area and world aggregates are included in the display of trade flows between major areas of the world. Reported data is supplemented by estimates whenever such data is not available or current. Imports are reported on a cost, insurance and freight (CIF) basis and exports are reported on a free on board (FOB) basis. Time series data includes estimates derived from reports of partner countries for non-reporting and slow-reporting countries.

        :param provider:
        :type provider: str
        :param country: The country to get data. None is an equiavlent to 'all'. If 'all' is used, the counterpart field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.
        :type country: str
        :param counterpart: Counterpart country to the trade. None is an equiavlent to 'all'. If 'all' is used, the country field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.
        :type counterpart: str
        :param direction: Trade direction. Use 'all' to get all data for this dimension.
        :type direction: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: The frequency of the data.
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_direction_of_trade_serialize(
            provider=provider,
            country=country,
            counterpart=counterpart,
            direction=direction,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectDirectionOfTrade",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_direction_of_trade_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. None is an equiavlent to 'all'. If 'all' is used, the counterpart field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.")] = None,
        counterpart: Annotated[Optional[StrictStr], Field(description="Counterpart country to the trade. None is an equiavlent to 'all'. If 'all' is used, the country field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="Trade direction. Use 'all' to get all data for this dimension.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectDirectionOfTrade]:
        """Direction Of Trade

        Get Direction Of Trade Statistics from the IMF database.  The Direction of Trade Statistics (DOTS) presents the value of merchandise exports and imports disaggregated according to a country's primary trading partners. Area and world aggregates are included in the display of trade flows between major areas of the world. Reported data is supplemented by estimates whenever such data is not available or current. Imports are reported on a cost, insurance and freight (CIF) basis and exports are reported on a free on board (FOB) basis. Time series data includes estimates derived from reports of partner countries for non-reporting and slow-reporting countries.

        :param provider:
        :type provider: str
        :param country: The country to get data. None is an equiavlent to 'all'. If 'all' is used, the counterpart field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.
        :type country: str
        :param counterpart: Counterpart country to the trade. None is an equiavlent to 'all'. If 'all' is used, the country field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.
        :type counterpart: str
        :param direction: Trade direction. Use 'all' to get all data for this dimension.
        :type direction: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: The frequency of the data.
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_direction_of_trade_serialize(
            provider=provider,
            country=country,
            counterpart=counterpart,
            direction=direction,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectDirectionOfTrade",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_direction_of_trade_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. None is an equiavlent to 'all'. If 'all' is used, the counterpart field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.")] = None,
        counterpart: Annotated[Optional[StrictStr], Field(description="Counterpart country to the trade. None is an equiavlent to 'all'. If 'all' is used, the country field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.")] = None,
        direction: Annotated[Optional[StrictStr], Field(description="Trade direction. Use 'all' to get all data for this dimension.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Direction Of Trade

        Get Direction Of Trade Statistics from the IMF database.  The Direction of Trade Statistics (DOTS) presents the value of merchandise exports and imports disaggregated according to a country's primary trading partners. Area and world aggregates are included in the display of trade flows between major areas of the world. Reported data is supplemented by estimates whenever such data is not available or current. Imports are reported on a cost, insurance and freight (CIF) basis and exports are reported on a free on board (FOB) basis. Time series data includes estimates derived from reports of partner countries for non-reporting and slow-reporting countries.

        :param provider:
        :type provider: str
        :param country: The country to get data. None is an equiavlent to 'all'. If 'all' is used, the counterpart field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.
        :type country: str
        :param counterpart: Counterpart country to the trade. None is an equiavlent to 'all'. If 'all' is used, the country field cannot be 'all'. Multiple comma separated items allowed for provider(s): imf.
        :type counterpart: str
        :param direction: Trade direction. Use 'all' to get all data for this dimension.
        :type direction: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: The frequency of the data.
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_direction_of_trade_serialize(
            provider=provider,
            country=country,
            counterpart=counterpart,
            direction=direction,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectDirectionOfTrade",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_direction_of_trade_serialize(
        self,
        provider,
        country,
        counterpart,
        direction,
        start_date,
        end_date,
        frequency,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if counterpart is not None:
            
            _query_params.append(('counterpart', counterpart))
            
        if direction is not None:
            
            _query_params.append(('direction', direction))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/direction_of_trade',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_export_destinations(
        self,
        country: Annotated[StrictStr, Field(description="The country to get data. Multiple comma separated items allowed for provider(s): econdb.")],
        provider: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectExportDestinations:
        """Export Destinations

        Get top export destinations by country from the UN Comtrade International Trade Statistics Database.

        :param country: The country to get data. Multiple comma separated items allowed for provider(s): econdb. (required)
        :type country: str
        :param provider:
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_export_destinations_serialize(
            country=country,
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectExportDestinations",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_export_destinations_with_http_info(
        self,
        country: Annotated[StrictStr, Field(description="The country to get data. Multiple comma separated items allowed for provider(s): econdb.")],
        provider: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectExportDestinations]:
        """Export Destinations

        Get top export destinations by country from the UN Comtrade International Trade Statistics Database.

        :param country: The country to get data. Multiple comma separated items allowed for provider(s): econdb. (required)
        :type country: str
        :param provider:
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_export_destinations_serialize(
            country=country,
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectExportDestinations",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_export_destinations_without_preload_content(
        self,
        country: Annotated[StrictStr, Field(description="The country to get data. Multiple comma separated items allowed for provider(s): econdb.")],
        provider: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export Destinations

        Get top export destinations by country from the UN Comtrade International Trade Statistics Database.

        :param country: The country to get data. Multiple comma separated items allowed for provider(s): econdb. (required)
        :type country: str
        :param provider:
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_export_destinations_serialize(
            country=country,
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectExportDestinations",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_export_destinations_serialize(
        self,
        country,
        provider,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/export_destinations',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_fred_regional(
        self,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for.")],
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of data entries to return.")] = None,
        is_series_group: Annotated[Optional[StrictBool], Field(description="When True, the symbol provided is for a series_group, else it is for a series ID. (provider: fred)")] = None,
        region_type: Annotated[Optional[StrictStr], Field(description="The type of regional data. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        season: Annotated[Optional[StrictStr], Field(description="The seasonal adjustments to the data. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="The units of the data. This should match the units returned from searching by series ID. An incorrect field will not necessarily return an error. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.              None = No change              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectFredRegional:
        """Fred Regional

        Query the Geo Fred API for regional economic data by series group.  The series group ID is found by using `fred_search` and the `series_id` parameter.

        :param symbol: Symbol to get data for. (required)
        :type symbol: str
        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param limit: The number of data entries to return.
        :type limit: int
        :param is_series_group: When True, the symbol provided is for a series_group, else it is for a series ID. (provider: fred)
        :type is_series_group: bool
        :param region_type: The type of regional data. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type region_type: str
        :param season: The seasonal adjustments to the data. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type season: str
        :param units: The units of the data. This should match the units returned from searching by series ID. An incorrect field will not necessarily return an error. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type units: str
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.              None = No change              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_regional_serialize(
            symbol=symbol,
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            is_series_group=is_series_group,
            region_type=region_type,
            season=season,
            units=units,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredRegional",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_fred_regional_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for.")],
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of data entries to return.")] = None,
        is_series_group: Annotated[Optional[StrictBool], Field(description="When True, the symbol provided is for a series_group, else it is for a series ID. (provider: fred)")] = None,
        region_type: Annotated[Optional[StrictStr], Field(description="The type of regional data. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        season: Annotated[Optional[StrictStr], Field(description="The seasonal adjustments to the data. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="The units of the data. This should match the units returned from searching by series ID. An incorrect field will not necessarily return an error. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.              None = No change              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectFredRegional]:
        """Fred Regional

        Query the Geo Fred API for regional economic data by series group.  The series group ID is found by using `fred_search` and the `series_id` parameter.

        :param symbol: Symbol to get data for. (required)
        :type symbol: str
        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param limit: The number of data entries to return.
        :type limit: int
        :param is_series_group: When True, the symbol provided is for a series_group, else it is for a series ID. (provider: fred)
        :type is_series_group: bool
        :param region_type: The type of regional data. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type region_type: str
        :param season: The seasonal adjustments to the data. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type season: str
        :param units: The units of the data. This should match the units returned from searching by series ID. An incorrect field will not necessarily return an error. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type units: str
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.              None = No change              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_regional_serialize(
            symbol=symbol,
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            is_series_group=is_series_group,
            region_type=region_type,
            season=season,
            units=units,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredRegional",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_fred_regional_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for.")],
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of data entries to return.")] = None,
        is_series_group: Annotated[Optional[StrictBool], Field(description="When True, the symbol provided is for a series_group, else it is for a series ID. (provider: fred)")] = None,
        region_type: Annotated[Optional[StrictStr], Field(description="The type of regional data. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        season: Annotated[Optional[StrictStr], Field(description="The seasonal adjustments to the data. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="The units of the data. This should match the units returned from searching by series ID. An incorrect field will not necessarily return an error. Parameter is only valid when `is_series_group` is True. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.              None = No change              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fred Regional

        Query the Geo Fred API for regional economic data by series group.  The series group ID is found by using `fred_search` and the `series_id` parameter.

        :param symbol: Symbol to get data for. (required)
        :type symbol: str
        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param limit: The number of data entries to return.
        :type limit: int
        :param is_series_group: When True, the symbol provided is for a series_group, else it is for a series ID. (provider: fred)
        :type is_series_group: bool
        :param region_type: The type of regional data. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type region_type: str
        :param season: The seasonal adjustments to the data. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type season: str
        :param units: The units of the data. This should match the units returned from searching by series ID. An incorrect field will not necessarily return an error. Parameter is only valid when `is_series_group` is True. (provider: fred)
        :type units: str
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.              None = No change              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_regional_serialize(
            symbol=symbol,
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            is_series_group=is_series_group,
            region_type=region_type,
            season=season,
            units=units,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredRegional",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_fred_regional_serialize(
        self,
        symbol,
        provider,
        start_date,
        end_date,
        limit,
        is_series_group,
        region_type,
        season,
        units,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if is_series_group is not None:
            
            _query_params.append(('is_series_group', is_series_group))
            
        if region_type is not None:
            
            _query_params.append(('region_type', region_type))
            
        if season is not None:
            
            _query_params.append(('season', season))
            
        if units is not None:
            
            _query_params.append(('units', units))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/fred_regional',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_fred_release_table(
        self,
        release_id: Annotated[StrictStr, Field(description="The ID of the release. Use `fred_search` to find releases.")],
        provider: Optional[StrictStr] = None,
        element_id: Annotated[Optional[StrictStr], Field(description="The element ID of a specific table in the release.")] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectFredReleaseTable:
        """Fred Release Table

        Get economic release data by ID and/or element from FRED.

        :param release_id: The ID of the release. Use `fred_search` to find releases. (required)
        :type release_id: str
        :param provider:
        :type provider: str
        :param element_id: The element ID of a specific table in the release.
        :type element_id: str
        :param var_date: A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date2
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_release_table_serialize(
            release_id=release_id,
            provider=provider,
            element_id=element_id,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredReleaseTable",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_fred_release_table_with_http_info(
        self,
        release_id: Annotated[StrictStr, Field(description="The ID of the release. Use `fred_search` to find releases.")],
        provider: Optional[StrictStr] = None,
        element_id: Annotated[Optional[StrictStr], Field(description="The element ID of a specific table in the release.")] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectFredReleaseTable]:
        """Fred Release Table

        Get economic release data by ID and/or element from FRED.

        :param release_id: The ID of the release. Use `fred_search` to find releases. (required)
        :type release_id: str
        :param provider:
        :type provider: str
        :param element_id: The element ID of a specific table in the release.
        :type element_id: str
        :param var_date: A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date2
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_release_table_serialize(
            release_id=release_id,
            provider=provider,
            element_id=element_id,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredReleaseTable",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_fred_release_table_without_preload_content(
        self,
        release_id: Annotated[StrictStr, Field(description="The ID of the release. Use `fred_search` to find releases.")],
        provider: Optional[StrictStr] = None,
        element_id: Annotated[Optional[StrictStr], Field(description="The element ID of a specific table in the release.")] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fred Release Table

        Get economic release data by ID and/or element from FRED.

        :param release_id: The ID of the release. Use `fred_search` to find releases. (required)
        :type release_id: str
        :param provider:
        :type provider: str
        :param element_id: The element ID of a specific table in the release.
        :type element_id: str
        :param var_date: A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date2
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_release_table_serialize(
            release_id=release_id,
            provider=provider,
            element_id=element_id,
            var_date=var_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredReleaseTable",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_fred_release_table_serialize(
        self,
        release_id,
        provider,
        element_id,
        var_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if release_id is not None:
            
            _query_params.append(('release_id', release_id))
            
        if element_id is not None:
            
            _query_params.append(('element_id', element_id))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/fred_release_table',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_fred_search(
        self,
        provider: Optional[StrictStr] = None,
        query: Annotated[Optional[StrictStr], Field(description="The search word(s).")] = None,
        search_type: Annotated[Optional[StrictStr], Field(description="The type of search to perform. Automatically set to 'release' when a 'release_id' is provided. (provider: fred)")] = None,
        release_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="A specific release ID to target. (provider: fred)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of data entries to return. (1-1000) (provider: fred)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset the results in conjunction with limit. This parameter is ignored When search_type is 'release'. (provider: fred)")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Order the results by a specific attribute. The default is 'observation_end'. (provider: fred)")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort the 'order_by' item in ascending or descending order. The default is 'desc'. (provider: fred)")] = None,
        filter_variable: Annotated[Optional[StrictStr], Field(description="Filter by an attribute. (provider: fred)")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="String value to filter the variable by.  Used in conjunction with filter_variable. This parameter is ignored when search_type is 'release'. (provider: fred)")] = None,
        tag_names: Annotated[Optional[StrictStr], Field(description="A semicolon delimited list of tag names that series match all of.  Example: 'japan;imports' This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)")] = None,
        exclude_tag_names: Annotated[Optional[StrictStr], Field(description="A semicolon delimited list of tag names that series match none of.  Example: 'imports;services'. Requires that variable tag_names also be set to limit the number of matching series. This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)")] = None,
        series_id: Annotated[Optional[StrictStr], Field(description="A FRED Series ID to return series group information for. This returns the required information to query for regional data. Not all series that are in FRED have geographical data. Entering a value for series_id will override all other parameters. Multiple series_ids can be separated by commas. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectFredSearch:
        """Fred Search

        Search for FRED series or economic releases by ID or string.  This does not return the observation values, only the metadata. Use this function to find series IDs for `fred_series()`.

        :param provider:
        :type provider: str
        :param query: The search word(s).
        :type query: str
        :param search_type: The type of search to perform. Automatically set to 'release' when a 'release_id' is provided. (provider: fred)
        :type search_type: str
        :param release_id: A specific release ID to target. (provider: fred)
        :type release_id: int
        :param limit: The number of data entries to return. (1-1000) (provider: fred)
        :type limit: int
        :param offset: Offset the results in conjunction with limit. This parameter is ignored When search_type is 'release'. (provider: fred)
        :type offset: int
        :param order_by: Order the results by a specific attribute. The default is 'observation_end'. (provider: fred)
        :type order_by: str
        :param sort_order: Sort the 'order_by' item in ascending or descending order. The default is 'desc'. (provider: fred)
        :type sort_order: str
        :param filter_variable: Filter by an attribute. (provider: fred)
        :type filter_variable: str
        :param filter_value: String value to filter the variable by.  Used in conjunction with filter_variable. This parameter is ignored when search_type is 'release'. (provider: fred)
        :type filter_value: str
        :param tag_names: A semicolon delimited list of tag names that series match all of.  Example: 'japan;imports' This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)
        :type tag_names: str
        :param exclude_tag_names: A semicolon delimited list of tag names that series match none of.  Example: 'imports;services'. Requires that variable tag_names also be set to limit the number of matching series. This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)
        :type exclude_tag_names: str
        :param series_id: A FRED Series ID to return series group information for. This returns the required information to query for regional data. Not all series that are in FRED have geographical data. Entering a value for series_id will override all other parameters. Multiple series_ids can be separated by commas. (provider: fred)
        :type series_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_search_serialize(
            provider=provider,
            query=query,
            search_type=search_type,
            release_id=release_id,
            limit=limit,
            offset=offset,
            order_by=order_by,
            sort_order=sort_order,
            filter_variable=filter_variable,
            filter_value=filter_value,
            tag_names=tag_names,
            exclude_tag_names=exclude_tag_names,
            series_id=series_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredSearch",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_fred_search_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        query: Annotated[Optional[StrictStr], Field(description="The search word(s).")] = None,
        search_type: Annotated[Optional[StrictStr], Field(description="The type of search to perform. Automatically set to 'release' when a 'release_id' is provided. (provider: fred)")] = None,
        release_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="A specific release ID to target. (provider: fred)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of data entries to return. (1-1000) (provider: fred)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset the results in conjunction with limit. This parameter is ignored When search_type is 'release'. (provider: fred)")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Order the results by a specific attribute. The default is 'observation_end'. (provider: fred)")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort the 'order_by' item in ascending or descending order. The default is 'desc'. (provider: fred)")] = None,
        filter_variable: Annotated[Optional[StrictStr], Field(description="Filter by an attribute. (provider: fred)")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="String value to filter the variable by.  Used in conjunction with filter_variable. This parameter is ignored when search_type is 'release'. (provider: fred)")] = None,
        tag_names: Annotated[Optional[StrictStr], Field(description="A semicolon delimited list of tag names that series match all of.  Example: 'japan;imports' This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)")] = None,
        exclude_tag_names: Annotated[Optional[StrictStr], Field(description="A semicolon delimited list of tag names that series match none of.  Example: 'imports;services'. Requires that variable tag_names also be set to limit the number of matching series. This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)")] = None,
        series_id: Annotated[Optional[StrictStr], Field(description="A FRED Series ID to return series group information for. This returns the required information to query for regional data. Not all series that are in FRED have geographical data. Entering a value for series_id will override all other parameters. Multiple series_ids can be separated by commas. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectFredSearch]:
        """Fred Search

        Search for FRED series or economic releases by ID or string.  This does not return the observation values, only the metadata. Use this function to find series IDs for `fred_series()`.

        :param provider:
        :type provider: str
        :param query: The search word(s).
        :type query: str
        :param search_type: The type of search to perform. Automatically set to 'release' when a 'release_id' is provided. (provider: fred)
        :type search_type: str
        :param release_id: A specific release ID to target. (provider: fred)
        :type release_id: int
        :param limit: The number of data entries to return. (1-1000) (provider: fred)
        :type limit: int
        :param offset: Offset the results in conjunction with limit. This parameter is ignored When search_type is 'release'. (provider: fred)
        :type offset: int
        :param order_by: Order the results by a specific attribute. The default is 'observation_end'. (provider: fred)
        :type order_by: str
        :param sort_order: Sort the 'order_by' item in ascending or descending order. The default is 'desc'. (provider: fred)
        :type sort_order: str
        :param filter_variable: Filter by an attribute. (provider: fred)
        :type filter_variable: str
        :param filter_value: String value to filter the variable by.  Used in conjunction with filter_variable. This parameter is ignored when search_type is 'release'. (provider: fred)
        :type filter_value: str
        :param tag_names: A semicolon delimited list of tag names that series match all of.  Example: 'japan;imports' This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)
        :type tag_names: str
        :param exclude_tag_names: A semicolon delimited list of tag names that series match none of.  Example: 'imports;services'. Requires that variable tag_names also be set to limit the number of matching series. This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)
        :type exclude_tag_names: str
        :param series_id: A FRED Series ID to return series group information for. This returns the required information to query for regional data. Not all series that are in FRED have geographical data. Entering a value for series_id will override all other parameters. Multiple series_ids can be separated by commas. (provider: fred)
        :type series_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_search_serialize(
            provider=provider,
            query=query,
            search_type=search_type,
            release_id=release_id,
            limit=limit,
            offset=offset,
            order_by=order_by,
            sort_order=sort_order,
            filter_variable=filter_variable,
            filter_value=filter_value,
            tag_names=tag_names,
            exclude_tag_names=exclude_tag_names,
            series_id=series_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredSearch",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_fred_search_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        query: Annotated[Optional[StrictStr], Field(description="The search word(s).")] = None,
        search_type: Annotated[Optional[StrictStr], Field(description="The type of search to perform. Automatically set to 'release' when a 'release_id' is provided. (provider: fred)")] = None,
        release_id: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="A specific release ID to target. (provider: fred)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="The number of data entries to return. (1-1000) (provider: fred)")] = None,
        offset: Annotated[Optional[Annotated[int, Field(strict=True, ge=0)]], Field(description="Offset the results in conjunction with limit. This parameter is ignored When search_type is 'release'. (provider: fred)")] = None,
        order_by: Annotated[Optional[StrictStr], Field(description="Order the results by a specific attribute. The default is 'observation_end'. (provider: fred)")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="Sort the 'order_by' item in ascending or descending order. The default is 'desc'. (provider: fred)")] = None,
        filter_variable: Annotated[Optional[StrictStr], Field(description="Filter by an attribute. (provider: fred)")] = None,
        filter_value: Annotated[Optional[StrictStr], Field(description="String value to filter the variable by.  Used in conjunction with filter_variable. This parameter is ignored when search_type is 'release'. (provider: fred)")] = None,
        tag_names: Annotated[Optional[StrictStr], Field(description="A semicolon delimited list of tag names that series match all of.  Example: 'japan;imports' This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)")] = None,
        exclude_tag_names: Annotated[Optional[StrictStr], Field(description="A semicolon delimited list of tag names that series match none of.  Example: 'imports;services'. Requires that variable tag_names also be set to limit the number of matching series. This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)")] = None,
        series_id: Annotated[Optional[StrictStr], Field(description="A FRED Series ID to return series group information for. This returns the required information to query for regional data. Not all series that are in FRED have geographical data. Entering a value for series_id will override all other parameters. Multiple series_ids can be separated by commas. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fred Search

        Search for FRED series or economic releases by ID or string.  This does not return the observation values, only the metadata. Use this function to find series IDs for `fred_series()`.

        :param provider:
        :type provider: str
        :param query: The search word(s).
        :type query: str
        :param search_type: The type of search to perform. Automatically set to 'release' when a 'release_id' is provided. (provider: fred)
        :type search_type: str
        :param release_id: A specific release ID to target. (provider: fred)
        :type release_id: int
        :param limit: The number of data entries to return. (1-1000) (provider: fred)
        :type limit: int
        :param offset: Offset the results in conjunction with limit. This parameter is ignored When search_type is 'release'. (provider: fred)
        :type offset: int
        :param order_by: Order the results by a specific attribute. The default is 'observation_end'. (provider: fred)
        :type order_by: str
        :param sort_order: Sort the 'order_by' item in ascending or descending order. The default is 'desc'. (provider: fred)
        :type sort_order: str
        :param filter_variable: Filter by an attribute. (provider: fred)
        :type filter_variable: str
        :param filter_value: String value to filter the variable by.  Used in conjunction with filter_variable. This parameter is ignored when search_type is 'release'. (provider: fred)
        :type filter_value: str
        :param tag_names: A semicolon delimited list of tag names that series match all of.  Example: 'japan;imports' This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)
        :type tag_names: str
        :param exclude_tag_names: A semicolon delimited list of tag names that series match none of.  Example: 'imports;services'. Requires that variable tag_names also be set to limit the number of matching series. This parameter is ignored when search_type is 'release'. Multiple comma separated items allowed. (provider: fred)
        :type exclude_tag_names: str
        :param series_id: A FRED Series ID to return series group information for. This returns the required information to query for regional data. Not all series that are in FRED have geographical data. Entering a value for series_id will override all other parameters. Multiple series_ids can be separated by commas. (provider: fred)
        :type series_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_search_serialize(
            provider=provider,
            query=query,
            search_type=search_type,
            release_id=release_id,
            limit=limit,
            offset=offset,
            order_by=order_by,
            sort_order=sort_order,
            filter_variable=filter_variable,
            filter_value=filter_value,
            tag_names=tag_names,
            exclude_tag_names=exclude_tag_names,
            series_id=series_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredSearch",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_fred_search_serialize(
        self,
        provider,
        query,
        search_type,
        release_id,
        limit,
        offset,
        order_by,
        sort_order,
        filter_variable,
        filter_value,
        tag_names,
        exclude_tag_names,
        series_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if search_type is not None:
            
            _query_params.append(('search_type', search_type))
            
        if release_id is not None:
            
            _query_params.append(('release_id', release_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if order_by is not None:
            
            _query_params.append(('order_by', order_by))
            
        if sort_order is not None:
            
            _query_params.append(('sort_order', sort_order))
            
        if filter_variable is not None:
            
            _query_params.append(('filter_variable', filter_variable))
            
        if filter_value is not None:
            
            _query_params.append(('filter_value', filter_value))
            
        if tag_names is not None:
            
            _query_params.append(('tag_names', tag_names))
            
        if exclude_tag_names is not None:
            
            _query_params.append(('exclude_tag_names', exclude_tag_names))
            
        if series_id is not None:
            
            _query_params.append(('series_id', series_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/fred_search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_fred_series(
        self,
        provider: StrictStr,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for. Multiple comma separated items allowed for provider(s): fred.")],
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of data entries to return.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.         None = No change         a = Annual         q = Quarterly         m = Monthly         w = Weekly         d = Daily         wef = Weekly, Ending Friday         weth = Weekly, Ending Thursday         wew = Weekly, Ending Wednesday         wetu = Weekly, Ending Tuesday         wem = Weekly, Ending Monday         wesu = Weekly, Ending Sunday         wesa = Weekly, Ending Saturday         bwew = Biweekly, Ending Wednesday         bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.         avg = Average         sum = Sum         eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type         None = No transformation         chg = Change         ch1 = Change from Year Ago         pch = Percent Change         pc1 = Percent Change from Year Ago         pca = Compounded Annual Rate of Change         cch = Continuously Compounded Rate of Change         cca = Continuously Compounded Annual Rate of Change         log = Natural Log          (provider: fred)")] = None,
        all_pages: Annotated[Optional[StrictBool], Field(description="Returns all pages of data from the API call at once. (provider: intrinio)")] = None,
        sleep: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Time to sleep between requests to avoid rate limiting. (provider: intrinio)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectFredSeries:
        """Fred Series

        Get data by series ID from FRED.

        :param provider: (required)
        :type provider: str
        :param symbol: Symbol to get data for. Multiple comma separated items allowed for provider(s): fred. (required)
        :type symbol: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param limit: The number of data entries to return.
        :type limit: int
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.         None = No change         a = Annual         q = Quarterly         m = Monthly         w = Weekly         d = Daily         wef = Weekly, Ending Friday         weth = Weekly, Ending Thursday         wew = Weekly, Ending Wednesday         wetu = Weekly, Ending Tuesday         wem = Weekly, Ending Monday         wesu = Weekly, Ending Sunday         wesa = Weekly, Ending Saturday         bwew = Biweekly, Ending Wednesday         bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.         avg = Average         sum = Sum         eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type         None = No transformation         chg = Change         ch1 = Change from Year Ago         pch = Percent Change         pc1 = Percent Change from Year Ago         pca = Compounded Annual Rate of Change         cch = Continuously Compounded Rate of Change         cca = Continuously Compounded Annual Rate of Change         log = Natural Log          (provider: fred)
        :type transform: str
        :param all_pages: Returns all pages of data from the API call at once. (provider: intrinio)
        :type all_pages: bool
        :param sleep: Time to sleep between requests to avoid rate limiting. (provider: intrinio)
        :type sleep: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_series_serialize(
            provider=provider,
            symbol=symbol,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            all_pages=all_pages,
            sleep=sleep,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredSeries",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_fred_series_with_http_info(
        self,
        provider: StrictStr,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for. Multiple comma separated items allowed for provider(s): fred.")],
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of data entries to return.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.         None = No change         a = Annual         q = Quarterly         m = Monthly         w = Weekly         d = Daily         wef = Weekly, Ending Friday         weth = Weekly, Ending Thursday         wew = Weekly, Ending Wednesday         wetu = Weekly, Ending Tuesday         wem = Weekly, Ending Monday         wesu = Weekly, Ending Sunday         wesa = Weekly, Ending Saturday         bwew = Biweekly, Ending Wednesday         bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.         avg = Average         sum = Sum         eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type         None = No transformation         chg = Change         ch1 = Change from Year Ago         pch = Percent Change         pc1 = Percent Change from Year Ago         pca = Compounded Annual Rate of Change         cch = Continuously Compounded Rate of Change         cca = Continuously Compounded Annual Rate of Change         log = Natural Log          (provider: fred)")] = None,
        all_pages: Annotated[Optional[StrictBool], Field(description="Returns all pages of data from the API call at once. (provider: intrinio)")] = None,
        sleep: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Time to sleep between requests to avoid rate limiting. (provider: intrinio)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectFredSeries]:
        """Fred Series

        Get data by series ID from FRED.

        :param provider: (required)
        :type provider: str
        :param symbol: Symbol to get data for. Multiple comma separated items allowed for provider(s): fred. (required)
        :type symbol: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param limit: The number of data entries to return.
        :type limit: int
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.         None = No change         a = Annual         q = Quarterly         m = Monthly         w = Weekly         d = Daily         wef = Weekly, Ending Friday         weth = Weekly, Ending Thursday         wew = Weekly, Ending Wednesday         wetu = Weekly, Ending Tuesday         wem = Weekly, Ending Monday         wesu = Weekly, Ending Sunday         wesa = Weekly, Ending Saturday         bwew = Biweekly, Ending Wednesday         bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.         avg = Average         sum = Sum         eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type         None = No transformation         chg = Change         ch1 = Change from Year Ago         pch = Percent Change         pc1 = Percent Change from Year Ago         pca = Compounded Annual Rate of Change         cch = Continuously Compounded Rate of Change         cca = Continuously Compounded Annual Rate of Change         log = Natural Log          (provider: fred)
        :type transform: str
        :param all_pages: Returns all pages of data from the API call at once. (provider: intrinio)
        :type all_pages: bool
        :param sleep: Time to sleep between requests to avoid rate limiting. (provider: intrinio)
        :type sleep: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_series_serialize(
            provider=provider,
            symbol=symbol,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            all_pages=all_pages,
            sleep=sleep,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredSeries",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_fred_series_without_preload_content(
        self,
        provider: StrictStr,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for. Multiple comma separated items allowed for provider(s): fred.")],
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of data entries to return.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.         None = No change         a = Annual         q = Quarterly         m = Monthly         w = Weekly         d = Daily         wef = Weekly, Ending Friday         weth = Weekly, Ending Thursday         wew = Weekly, Ending Wednesday         wetu = Weekly, Ending Tuesday         wem = Weekly, Ending Monday         wesu = Weekly, Ending Sunday         wesa = Weekly, Ending Saturday         bwew = Biweekly, Ending Wednesday         bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.         avg = Average         sum = Sum         eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type         None = No transformation         chg = Change         ch1 = Change from Year Ago         pch = Percent Change         pc1 = Percent Change from Year Ago         pca = Compounded Annual Rate of Change         cch = Continuously Compounded Rate of Change         cca = Continuously Compounded Annual Rate of Change         log = Natural Log          (provider: fred)")] = None,
        all_pages: Annotated[Optional[StrictBool], Field(description="Returns all pages of data from the API call at once. (provider: intrinio)")] = None,
        sleep: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Time to sleep between requests to avoid rate limiting. (provider: intrinio)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Fred Series

        Get data by series ID from FRED.

        :param provider: (required)
        :type provider: str
        :param symbol: Symbol to get data for. Multiple comma separated items allowed for provider(s): fred. (required)
        :type symbol: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param limit: The number of data entries to return.
        :type limit: int
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.         None = No change         a = Annual         q = Quarterly         m = Monthly         w = Weekly         d = Daily         wef = Weekly, Ending Friday         weth = Weekly, Ending Thursday         wew = Weekly, Ending Wednesday         wetu = Weekly, Ending Tuesday         wem = Weekly, Ending Monday         wesu = Weekly, Ending Sunday         wesa = Weekly, Ending Saturday         bwew = Biweekly, Ending Wednesday         bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set.         avg = Average         sum = Sum         eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type         None = No transformation         chg = Change         ch1 = Change from Year Ago         pch = Percent Change         pc1 = Percent Change from Year Ago         pca = Compounded Annual Rate of Change         cch = Continuously Compounded Rate of Change         cca = Continuously Compounded Annual Rate of Change         log = Natural Log          (provider: fred)
        :type transform: str
        :param all_pages: Returns all pages of data from the API call at once. (provider: intrinio)
        :type all_pages: bool
        :param sleep: Time to sleep between requests to avoid rate limiting. (provider: intrinio)
        :type sleep: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_fred_series_serialize(
            provider=provider,
            symbol=symbol,
            start_date=start_date,
            end_date=end_date,
            limit=limit,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            all_pages=all_pages,
            sleep=sleep,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFredSeries",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_fred_series_serialize(
        self,
        provider,
        symbol,
        start_date,
        end_date,
        limit,
        frequency,
        aggregation_method,
        transform,
        all_pages,
        sleep,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        if all_pages is not None:
            
            _query_params.append(('all_pages', all_pages))
            
        if sleep is not None:
            
            _query_params.append(('sleep', sleep))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/fred_series',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_gdp_forecast(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country, or countries, to get forward GDP projections for. Default is all. Multiple comma separated items allowed. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data, default is annual. (provider: oecd)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="Units of the data, default is volume (chain linked volume, 2015). 'current_prices', 'volume', and 'capita' are expressed in USD; 'growth' as a percent; 'deflator' as an index. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectGdpForecast:
        """Forecast

        Get Forecasted GDP Data.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country, or countries, to get forward GDP projections for. Default is all. Multiple comma separated items allowed. (provider: oecd)
        :type country: str
        :param frequency: Frequency of the data, default is annual. (provider: oecd)
        :type frequency: str
        :param units: Units of the data, default is volume (chain linked volume, 2015). 'current_prices', 'volume', and 'capita' are expressed in USD; 'growth' as a percent; 'deflator' as an index. (provider: oecd)
        :type units: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_forecast_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            units=units,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpForecast",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_gdp_forecast_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country, or countries, to get forward GDP projections for. Default is all. Multiple comma separated items allowed. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data, default is annual. (provider: oecd)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="Units of the data, default is volume (chain linked volume, 2015). 'current_prices', 'volume', and 'capita' are expressed in USD; 'growth' as a percent; 'deflator' as an index. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectGdpForecast]:
        """Forecast

        Get Forecasted GDP Data.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country, or countries, to get forward GDP projections for. Default is all. Multiple comma separated items allowed. (provider: oecd)
        :type country: str
        :param frequency: Frequency of the data, default is annual. (provider: oecd)
        :type frequency: str
        :param units: Units of the data, default is volume (chain linked volume, 2015). 'current_prices', 'volume', and 'capita' are expressed in USD; 'growth' as a percent; 'deflator' as an index. (provider: oecd)
        :type units: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_forecast_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            units=units,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpForecast",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_gdp_forecast_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country, or countries, to get forward GDP projections for. Default is all. Multiple comma separated items allowed. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data, default is annual. (provider: oecd)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="Units of the data, default is volume (chain linked volume, 2015). 'current_prices', 'volume', and 'capita' are expressed in USD; 'growth' as a percent; 'deflator' as an index. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Forecast

        Get Forecasted GDP Data.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country, or countries, to get forward GDP projections for. Default is all. Multiple comma separated items allowed. (provider: oecd)
        :type country: str
        :param frequency: Frequency of the data, default is annual. (provider: oecd)
        :type frequency: str
        :param units: Units of the data, default is volume (chain linked volume, 2015). 'current_prices', 'volume', and 'capita' are expressed in USD; 'growth' as a percent; 'deflator' as an index. (provider: oecd)
        :type units: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_forecast_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            units=units,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpForecast",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_gdp_forecast_serialize(
        self,
        provider,
        start_date,
        end_date,
        country,
        frequency,
        units,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if units is not None:
            
            _query_params.append(('units', units))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/gdp/forecast',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_gdp_nominal(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data. (provider: oecd)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="The unit of measurement for the data.Both 'level' and 'capita' (per) are measured in USD. (provider: oecd)")] = None,
        price_base: Annotated[Optional[StrictStr], Field(description="Price base for the data, volume is chain linked volume. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectGdpNominal:
        """Nominal

        Get Nominal GDP Data.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)
        :type country: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param frequency: Frequency of the data. (provider: oecd)
        :type frequency: str
        :param units: The unit of measurement for the data.Both 'level' and 'capita' (per) are measured in USD. (provider: oecd)
        :type units: str
        :param price_base: Price base for the data, volume is chain linked volume. (provider: oecd)
        :type price_base: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_nominal_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            use_cache=use_cache,
            frequency=frequency,
            units=units,
            price_base=price_base,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpNominal",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_gdp_nominal_with_http_info(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data. (provider: oecd)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="The unit of measurement for the data.Both 'level' and 'capita' (per) are measured in USD. (provider: oecd)")] = None,
        price_base: Annotated[Optional[StrictStr], Field(description="Price base for the data, volume is chain linked volume. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectGdpNominal]:
        """Nominal

        Get Nominal GDP Data.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)
        :type country: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param frequency: Frequency of the data. (provider: oecd)
        :type frequency: str
        :param units: The unit of measurement for the data.Both 'level' and 'capita' (per) are measured in USD. (provider: oecd)
        :type units: str
        :param price_base: Price base for the data, volume is chain linked volume. (provider: oecd)
        :type price_base: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_nominal_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            use_cache=use_cache,
            frequency=frequency,
            units=units,
            price_base=price_base,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpNominal",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_gdp_nominal_without_preload_content(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data. (provider: oecd)")] = None,
        units: Annotated[Optional[StrictStr], Field(description="The unit of measurement for the data.Both 'level' and 'capita' (per) are measured in USD. (provider: oecd)")] = None,
        price_base: Annotated[Optional[StrictStr], Field(description="Price base for the data, volume is chain linked volume. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Nominal

        Get Nominal GDP Data.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)
        :type country: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param frequency: Frequency of the data. (provider: oecd)
        :type frequency: str
        :param units: The unit of measurement for the data.Both 'level' and 'capita' (per) are measured in USD. (provider: oecd)
        :type units: str
        :param price_base: Price base for the data, volume is chain linked volume. (provider: oecd)
        :type price_base: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_nominal_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            use_cache=use_cache,
            frequency=frequency,
            units=units,
            price_base=price_base,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpNominal",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_gdp_nominal_serialize(
        self,
        provider,
        start_date,
        end_date,
        country,
        use_cache,
        frequency,
        units,
        price_base,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if use_cache is not None:
            
            _query_params.append(('use_cache', use_cache))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if units is not None:
            
            _query_params.append(('units', units))
            
        if price_base is not None:
            
            _query_params.append(('price_base', price_base))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/gdp/nominal',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_gdp_real(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectGdpReal:
        """Real

        Get Real GDP Data.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)
        :type country: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param frequency: Frequency of the data. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_real_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            use_cache=use_cache,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpReal",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_gdp_real_with_http_info(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectGdpReal]:
        """Real

        Get Real GDP Data.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)
        :type country: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param frequency: Frequency of the data. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_real_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            use_cache=use_cache,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpReal",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_gdp_real_without_preload_content(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency of the data. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Real

        Get Real GDP Data.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: The country to get data.Use 'all' to get data for all available countries. Multiple comma separated items allowed. (provider: econdb, oecd)
        :type country: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param frequency: Frequency of the data. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_gdp_real_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            use_cache=use_cache,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectGdpReal",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_gdp_real_serialize(
        self,
        provider,
        start_date,
        end_date,
        country,
        use_cache,
        frequency,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if use_cache is not None:
            
            _query_params.append(('use_cache', use_cache))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/gdp/real',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_house_price_index(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectHousePriceIndex:
        """House Price Index

        Get the House Price Index by country from the OECD Short-Term Economics Statistics.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param transform: Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).
        :type transform: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_house_price_index_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            transform=transform,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectHousePriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_house_price_index_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectHousePriceIndex]:
        """House Price Index

        Get the House Price Index by country from the OECD Short-Term Economics Statistics.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param transform: Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).
        :type transform: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_house_price_index_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            transform=transform,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectHousePriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_house_price_index_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """House Price Index

        Get the House Price Index by country from the OECD Short-Term Economics Statistics.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param transform: Transformation of the CPI data. Period represents the change since previous. Defaults to change from one year ago (yoy).
        :type transform: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_house_price_index_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            transform=transform,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectHousePriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_house_price_index_serialize(
        self,
        provider,
        country,
        frequency,
        transform,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/house_price_index',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_immediate_interest_rate(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectImmediateInterestRate:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get immediate interest rates by country.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: The frequency of the data. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/immediate_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_immediate_interest_rate_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectImmediateInterestRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_immediate_interest_rate_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectImmediateInterestRate]:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get immediate interest rates by country.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: The frequency of the data. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/immediate_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_immediate_interest_rate_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectImmediateInterestRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_immediate_interest_rate_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get immediate interest rates by country.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: The frequency of the data. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/immediate_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_immediate_interest_rate_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectImmediateInterestRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_immediate_interest_rate_serialize(
        self,
        provider,
        country,
        start_date,
        end_date,
        frequency,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/immediate_interest_rate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_indicators(
        self,
        provider: StrictStr,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. The country represented by the indicator, if available. Multiple comma separated items allowed for provider(s): econdb, imf.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        symbol: Annotated[Optional[StrictStr], Field(description="Symbol to get data for. The base symbol for the indicator (e.g. GDP, CPI, etc.). Use `available_indicators()` to get a list of available symbols. Multiple comma separated items allowed. (provider: econdb);     Symbol to get data for. Use `available_indicators()` to get the list of available symbols. Use 'IRFCL' to get all the data from the set of indicators. Complete tables are available only by single country, and are keyed as described below. The default is 'irfcl_top_lines'. Available presets not listed in `available_indicators()` are:          'IRFCL': All the data from the set of indicators. Not compatible with multiple countries.         'irfcl_top_lines': The default, top line items from the IRFCL data. Compatible with multiple countries.         'reserve_assets_and_other_fx_assets': Table I of the IRFCL data. Not compatible with multiple countries.         'predetermined_drains_on_fx_assets': Table II of the IRFCL data. Not compatible with multiple countries.         'contingent_drains_fx_assets': Table III of the IRFCL data. Not compatible with multiple countries.         'memorandum_items': The memorandum items table of the IRFCL data. Not compatible with multiple countries.         'gold_reserves': Gold reserves as value in USD and Fine Troy Ounces. Compatible with multiple countries.         'derivative_assets': Net derivative assets as value in USD. Compatible with multipile countries.      Multiple comma separated items allowed. (provider: imf)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="The transformation to apply to the data, default is None.      tpop: Change from previous period     toya: Change from one year ago     tusd: Values as US dollars     tpgp: Values as a percent of GDP      Only 'tpop' and 'toya' are applicable to all indicators. Applying transformations across multiple indicators/countries may produce unexpected results.     This is because not all indicators are compatible with all transformations, and the original units and scale differ between entities.     `tusd` should only be used where values are currencies. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data, default is 'quarter'. Only valid when 'symbol' is 'main'. (provider: econdb);     Frequency of the data. (provider: imf)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectEconomicIndicators:
        """Indicators

        Get economic indicators by country and indicator.

        :param provider: (required)
        :type provider: str
        :param country: The country to get data. The country represented by the indicator, if available. Multiple comma separated items allowed for provider(s): econdb, imf.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param symbol: Symbol to get data for. The base symbol for the indicator (e.g. GDP, CPI, etc.). Use `available_indicators()` to get a list of available symbols. Multiple comma separated items allowed. (provider: econdb);     Symbol to get data for. Use `available_indicators()` to get the list of available symbols. Use 'IRFCL' to get all the data from the set of indicators. Complete tables are available only by single country, and are keyed as described below. The default is 'irfcl_top_lines'. Available presets not listed in `available_indicators()` are:          'IRFCL': All the data from the set of indicators. Not compatible with multiple countries.         'irfcl_top_lines': The default, top line items from the IRFCL data. Compatible with multiple countries.         'reserve_assets_and_other_fx_assets': Table I of the IRFCL data. Not compatible with multiple countries.         'predetermined_drains_on_fx_assets': Table II of the IRFCL data. Not compatible with multiple countries.         'contingent_drains_fx_assets': Table III of the IRFCL data. Not compatible with multiple countries.         'memorandum_items': The memorandum items table of the IRFCL data. Not compatible with multiple countries.         'gold_reserves': Gold reserves as value in USD and Fine Troy Ounces. Compatible with multiple countries.         'derivative_assets': Net derivative assets as value in USD. Compatible with multipile countries.      Multiple comma separated items allowed. (provider: imf)
        :type symbol: str
        :param transform: The transformation to apply to the data, default is None.      tpop: Change from previous period     toya: Change from one year ago     tusd: Values as US dollars     tpgp: Values as a percent of GDP      Only 'tpop' and 'toya' are applicable to all indicators. Applying transformations across multiple indicators/countries may produce unexpected results.     This is because not all indicators are compatible with all transformations, and the original units and scale differ between entities.     `tusd` should only be used where values are currencies. (provider: econdb)
        :type transform: str
        :param frequency: The frequency of the data, default is 'quarter'. Only valid when 'symbol' is 'main'. (provider: econdb);     Frequency of the data. (provider: imf)
        :type frequency: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_indicators_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            symbol=symbol,
            transform=transform,
            frequency=frequency,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEconomicIndicators",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_indicators_with_http_info(
        self,
        provider: StrictStr,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. The country represented by the indicator, if available. Multiple comma separated items allowed for provider(s): econdb, imf.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        symbol: Annotated[Optional[StrictStr], Field(description="Symbol to get data for. The base symbol for the indicator (e.g. GDP, CPI, etc.). Use `available_indicators()` to get a list of available symbols. Multiple comma separated items allowed. (provider: econdb);     Symbol to get data for. Use `available_indicators()` to get the list of available symbols. Use 'IRFCL' to get all the data from the set of indicators. Complete tables are available only by single country, and are keyed as described below. The default is 'irfcl_top_lines'. Available presets not listed in `available_indicators()` are:          'IRFCL': All the data from the set of indicators. Not compatible with multiple countries.         'irfcl_top_lines': The default, top line items from the IRFCL data. Compatible with multiple countries.         'reserve_assets_and_other_fx_assets': Table I of the IRFCL data. Not compatible with multiple countries.         'predetermined_drains_on_fx_assets': Table II of the IRFCL data. Not compatible with multiple countries.         'contingent_drains_fx_assets': Table III of the IRFCL data. Not compatible with multiple countries.         'memorandum_items': The memorandum items table of the IRFCL data. Not compatible with multiple countries.         'gold_reserves': Gold reserves as value in USD and Fine Troy Ounces. Compatible with multiple countries.         'derivative_assets': Net derivative assets as value in USD. Compatible with multipile countries.      Multiple comma separated items allowed. (provider: imf)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="The transformation to apply to the data, default is None.      tpop: Change from previous period     toya: Change from one year ago     tusd: Values as US dollars     tpgp: Values as a percent of GDP      Only 'tpop' and 'toya' are applicable to all indicators. Applying transformations across multiple indicators/countries may produce unexpected results.     This is because not all indicators are compatible with all transformations, and the original units and scale differ between entities.     `tusd` should only be used where values are currencies. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data, default is 'quarter'. Only valid when 'symbol' is 'main'. (provider: econdb);     Frequency of the data. (provider: imf)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectEconomicIndicators]:
        """Indicators

        Get economic indicators by country and indicator.

        :param provider: (required)
        :type provider: str
        :param country: The country to get data. The country represented by the indicator, if available. Multiple comma separated items allowed for provider(s): econdb, imf.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param symbol: Symbol to get data for. The base symbol for the indicator (e.g. GDP, CPI, etc.). Use `available_indicators()` to get a list of available symbols. Multiple comma separated items allowed. (provider: econdb);     Symbol to get data for. Use `available_indicators()` to get the list of available symbols. Use 'IRFCL' to get all the data from the set of indicators. Complete tables are available only by single country, and are keyed as described below. The default is 'irfcl_top_lines'. Available presets not listed in `available_indicators()` are:          'IRFCL': All the data from the set of indicators. Not compatible with multiple countries.         'irfcl_top_lines': The default, top line items from the IRFCL data. Compatible with multiple countries.         'reserve_assets_and_other_fx_assets': Table I of the IRFCL data. Not compatible with multiple countries.         'predetermined_drains_on_fx_assets': Table II of the IRFCL data. Not compatible with multiple countries.         'contingent_drains_fx_assets': Table III of the IRFCL data. Not compatible with multiple countries.         'memorandum_items': The memorandum items table of the IRFCL data. Not compatible with multiple countries.         'gold_reserves': Gold reserves as value in USD and Fine Troy Ounces. Compatible with multiple countries.         'derivative_assets': Net derivative assets as value in USD. Compatible with multipile countries.      Multiple comma separated items allowed. (provider: imf)
        :type symbol: str
        :param transform: The transformation to apply to the data, default is None.      tpop: Change from previous period     toya: Change from one year ago     tusd: Values as US dollars     tpgp: Values as a percent of GDP      Only 'tpop' and 'toya' are applicable to all indicators. Applying transformations across multiple indicators/countries may produce unexpected results.     This is because not all indicators are compatible with all transformations, and the original units and scale differ between entities.     `tusd` should only be used where values are currencies. (provider: econdb)
        :type transform: str
        :param frequency: The frequency of the data, default is 'quarter'. Only valid when 'symbol' is 'main'. (provider: econdb);     Frequency of the data. (provider: imf)
        :type frequency: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_indicators_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            symbol=symbol,
            transform=transform,
            frequency=frequency,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEconomicIndicators",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_indicators_without_preload_content(
        self,
        provider: StrictStr,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. The country represented by the indicator, if available. Multiple comma separated items allowed for provider(s): econdb, imf.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        symbol: Annotated[Optional[StrictStr], Field(description="Symbol to get data for. The base symbol for the indicator (e.g. GDP, CPI, etc.). Use `available_indicators()` to get a list of available symbols. Multiple comma separated items allowed. (provider: econdb);     Symbol to get data for. Use `available_indicators()` to get the list of available symbols. Use 'IRFCL' to get all the data from the set of indicators. Complete tables are available only by single country, and are keyed as described below. The default is 'irfcl_top_lines'. Available presets not listed in `available_indicators()` are:          'IRFCL': All the data from the set of indicators. Not compatible with multiple countries.         'irfcl_top_lines': The default, top line items from the IRFCL data. Compatible with multiple countries.         'reserve_assets_and_other_fx_assets': Table I of the IRFCL data. Not compatible with multiple countries.         'predetermined_drains_on_fx_assets': Table II of the IRFCL data. Not compatible with multiple countries.         'contingent_drains_fx_assets': Table III of the IRFCL data. Not compatible with multiple countries.         'memorandum_items': The memorandum items table of the IRFCL data. Not compatible with multiple countries.         'gold_reserves': Gold reserves as value in USD and Fine Troy Ounces. Compatible with multiple countries.         'derivative_assets': Net derivative assets as value in USD. Compatible with multipile countries.      Multiple comma separated items allowed. (provider: imf)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="The transformation to apply to the data, default is None.      tpop: Change from previous period     toya: Change from one year ago     tusd: Values as US dollars     tpgp: Values as a percent of GDP      Only 'tpop' and 'toya' are applicable to all indicators. Applying transformations across multiple indicators/countries may produce unexpected results.     This is because not all indicators are compatible with all transformations, and the original units and scale differ between entities.     `tusd` should only be used where values are currencies. (provider: econdb)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data, default is 'quarter'. Only valid when 'symbol' is 'main'. (provider: econdb);     Frequency of the data. (provider: imf)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Indicators

        Get economic indicators by country and indicator.

        :param provider: (required)
        :type provider: str
        :param country: The country to get data. The country represented by the indicator, if available. Multiple comma separated items allowed for provider(s): econdb, imf.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param symbol: Symbol to get data for. The base symbol for the indicator (e.g. GDP, CPI, etc.). Use `available_indicators()` to get a list of available symbols. Multiple comma separated items allowed. (provider: econdb);     Symbol to get data for. Use `available_indicators()` to get the list of available symbols. Use 'IRFCL' to get all the data from the set of indicators. Complete tables are available only by single country, and are keyed as described below. The default is 'irfcl_top_lines'. Available presets not listed in `available_indicators()` are:          'IRFCL': All the data from the set of indicators. Not compatible with multiple countries.         'irfcl_top_lines': The default, top line items from the IRFCL data. Compatible with multiple countries.         'reserve_assets_and_other_fx_assets': Table I of the IRFCL data. Not compatible with multiple countries.         'predetermined_drains_on_fx_assets': Table II of the IRFCL data. Not compatible with multiple countries.         'contingent_drains_fx_assets': Table III of the IRFCL data. Not compatible with multiple countries.         'memorandum_items': The memorandum items table of the IRFCL data. Not compatible with multiple countries.         'gold_reserves': Gold reserves as value in USD and Fine Troy Ounces. Compatible with multiple countries.         'derivative_assets': Net derivative assets as value in USD. Compatible with multipile countries.      Multiple comma separated items allowed. (provider: imf)
        :type symbol: str
        :param transform: The transformation to apply to the data, default is None.      tpop: Change from previous period     toya: Change from one year ago     tusd: Values as US dollars     tpgp: Values as a percent of GDP      Only 'tpop' and 'toya' are applicable to all indicators. Applying transformations across multiple indicators/countries may produce unexpected results.     This is because not all indicators are compatible with all transformations, and the original units and scale differ between entities.     `tusd` should only be used where values are currencies. (provider: econdb)
        :type transform: str
        :param frequency: The frequency of the data, default is 'quarter'. Only valid when 'symbol' is 'main'. (provider: econdb);     Frequency of the data. (provider: imf)
        :type frequency: str
        :param use_cache: If True, the request will be cached for one day. Using cache is recommended to avoid needlessly requesting the same data. (provider: econdb)
        :type use_cache: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_indicators_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            symbol=symbol,
            transform=transform,
            frequency=frequency,
            use_cache=use_cache,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEconomicIndicators",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_indicators_serialize(
        self,
        provider,
        country,
        start_date,
        end_date,
        symbol,
        transform,
        frequency,
        use_cache,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if use_cache is not None:
            
            _query_params.append(('use_cache', use_cache))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/indicators',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_interest_rates(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        duration: Annotated[Optional[StrictStr], Field(description="Duration of the interest rate. 'immediate' is the overnight rate, 'short' is the 3-month rate, and 'long' is the 10-year rate. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectCountryInterestRates:
        """Interest Rates

        Get interest rates by country(s) and duration. Most OECD countries publish short-term, a long-term, and immediate rates monthly.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param duration: Duration of the interest rate. 'immediate' is the overnight rate, 'short' is the 3-month rate, and 'long' is the 10-year rate. (provider: oecd)
        :type duration: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_interest_rates_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            duration=duration,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCountryInterestRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_interest_rates_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        duration: Annotated[Optional[StrictStr], Field(description="Duration of the interest rate. 'immediate' is the overnight rate, 'short' is the 3-month rate, and 'long' is the 10-year rate. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectCountryInterestRates]:
        """Interest Rates

        Get interest rates by country(s) and duration. Most OECD countries publish short-term, a long-term, and immediate rates monthly.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param duration: Duration of the interest rate. 'immediate' is the overnight rate, 'short' is the 3-month rate, and 'long' is the 10-year rate. (provider: oecd)
        :type duration: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_interest_rates_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            duration=duration,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCountryInterestRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_interest_rates_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        duration: Annotated[Optional[StrictStr], Field(description="Duration of the interest rate. 'immediate' is the overnight rate, 'short' is the 3-month rate, and 'long' is the 10-year rate. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Interest Rates

        Get interest rates by country(s) and duration. Most OECD countries publish short-term, a long-term, and immediate rates monthly.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param duration: Duration of the interest rate. 'immediate' is the overnight rate, 'short' is the 3-month rate, and 'long' is the 10-year rate. (provider: oecd)
        :type duration: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_interest_rates_serialize(
            provider=provider,
            country=country,
            start_date=start_date,
            end_date=end_date,
            duration=duration,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCountryInterestRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_interest_rates_serialize(
        self,
        provider,
        country,
        start_date,
        end_date,
        duration,
        frequency,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/interest_rates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_long_term_interest_rate(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country to get interest rate for. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectLTIR:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get Long-term interest rates that refer to government bonds maturing in ten years.  Rates are mainly determined by the price charged by the lender, the risk from the borrower and the fall in the capital value. Long-term interest rates are generally averages of daily rates, measured as a percentage. These interest rates are implied by the prices at which the government bonds are traded on financial markets, not the interest rates at which the loans were issued. In all cases, they refer to bonds whose capital repayment is guaranteed by governments. Long-term interest rates are one of the determinants of business investment. Low long-term interest rates encourage investment in new equipment and high interest rates discourage it. Investment is, in turn, a major source of economic growth.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get interest rate for. (provider: oecd)
        :type country: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/long_term_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_long_term_interest_rate_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectLTIR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_long_term_interest_rate_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country to get interest rate for. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectLTIR]:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get Long-term interest rates that refer to government bonds maturing in ten years.  Rates are mainly determined by the price charged by the lender, the risk from the borrower and the fall in the capital value. Long-term interest rates are generally averages of daily rates, measured as a percentage. These interest rates are implied by the prices at which the government bonds are traded on financial markets, not the interest rates at which the loans were issued. In all cases, they refer to bonds whose capital repayment is guaranteed by governments. Long-term interest rates are one of the determinants of business investment. Low long-term interest rates encourage investment in new equipment and high interest rates discourage it. Investment is, in turn, a major source of economic growth.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get interest rate for. (provider: oecd)
        :type country: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/long_term_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_long_term_interest_rate_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectLTIR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_long_term_interest_rate_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country to get interest rate for. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get Long-term interest rates that refer to government bonds maturing in ten years.  Rates are mainly determined by the price charged by the lender, the risk from the borrower and the fall in the capital value. Long-term interest rates are generally averages of daily rates, measured as a percentage. These interest rates are implied by the prices at which the government bonds are traded on financial markets, not the interest rates at which the loans were issued. In all cases, they refer to bonds whose capital repayment is guaranteed by governments. Long-term interest rates are one of the determinants of business investment. Low long-term interest rates encourage investment in new equipment and high interest rates discourage it. Investment is, in turn, a major source of economic growth.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get interest rate for. (provider: oecd)
        :type country: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/long_term_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_long_term_interest_rate_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectLTIR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_long_term_interest_rate_serialize(
        self,
        provider,
        start_date,
        end_date,
        country,
        frequency,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/long_term_interest_rate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_money_measures(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        adjusted: Annotated[Optional[StrictBool], Field(description="Whether to return seasonally adjusted data.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectMoneyMeasures:
        """Money Measures

        Get Money Measures (M1/M2 and components).  The Federal Reserve publishes as part of the H.6 Release.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param adjusted: Whether to return seasonally adjusted data.
        :type adjusted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_money_measures_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            adjusted=adjusted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMoneyMeasures",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_money_measures_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        adjusted: Annotated[Optional[StrictBool], Field(description="Whether to return seasonally adjusted data.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectMoneyMeasures]:
        """Money Measures

        Get Money Measures (M1/M2 and components).  The Federal Reserve publishes as part of the H.6 Release.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param adjusted: Whether to return seasonally adjusted data.
        :type adjusted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_money_measures_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            adjusted=adjusted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMoneyMeasures",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_money_measures_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        adjusted: Annotated[Optional[StrictBool], Field(description="Whether to return seasonally adjusted data.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Money Measures

        Get Money Measures (M1/M2 and components).  The Federal Reserve publishes as part of the H.6 Release.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param adjusted: Whether to return seasonally adjusted data.
        :type adjusted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_money_measures_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            adjusted=adjusted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMoneyMeasures",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_money_measures_serialize(
        self,
        provider,
        start_date,
        end_date,
        adjusted,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if adjusted is not None:
            
            _query_params.append(('adjusted', adjusted))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/money_measures',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_pce(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category to query. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectPersonalConsumptionExpenditures:
        """Pce

        Get Personal Consumption Expenditures (PCE) reports.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date3
        :param category: The category to query. (provider: fred)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_pce_serialize(
            provider=provider,
            var_date=var_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPersonalConsumptionExpenditures",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_pce_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category to query. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectPersonalConsumptionExpenditures]:
        """Pce

        Get Personal Consumption Expenditures (PCE) reports.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date3
        :param category: The category to query. (provider: fred)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_pce_serialize(
            provider=provider,
            var_date=var_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPersonalConsumptionExpenditures",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_pce_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category to query. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Pce

        Get Personal Consumption Expenditures (PCE) reports.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date3
        :param category: The category to query. (provider: fred)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_pce_serialize(
            provider=provider,
            var_date=var_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPersonalConsumptionExpenditures",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_pce_serialize(
        self,
        provider,
        var_date,
        category,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/pce',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_port_volume(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectPortVolume:
        """Port Volume

        Get average dwelling times and TEU volumes from the top ports.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_port_volume_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPortVolume",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_port_volume_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectPortVolume]:
        """Port Volume

        Get average dwelling times and TEU volumes from the top ports.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_port_volume_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPortVolume",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_port_volume_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Port Volume

        Get average dwelling times and TEU volumes from the top ports.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_port_volume_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPortVolume",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_port_volume_serialize(
        self,
        provider,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/port_volume',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_primary_dealer_fails(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        asset_class: Annotated[Optional[StrictStr], Field(description="Asset class to return, default is 'all'. (provider: federal_reserve)")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="Unit of the data returned to the 'value' field. Default is 'value', which represents millions of USD. 'percent' returns data as the percentage of the total fails-to-receive and fails-to-deliver, by asset class. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectPrimaryDealerFails:
        """Primary Dealer Fails

        Primary Dealer Statistics for Fails to Deliver and Fails to Receive.  Data from the NY Federal Reserve are updated on Thursdays at approximately 4:15 p.m. with the previous week's statistics.  For research on the topic, see: https://www.federalreserve.gov/econres/notes/feds-notes/the-systemic-nature-of-settlement-fails-20170703.html  \"Large and protracted settlement fails are believed to undermine the liquidity and well-functioning of securities markets.  Near-100 percent pass-through of fails suggests a high degree of collateral re-hypothecation together with the inability or unwillingness to borrow or buy the needed securities.\"

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param asset_class: Asset class to return, default is 'all'. (provider: federal_reserve)
        :type asset_class: str
        :param unit: Unit of the data returned to the 'value' field. Default is 'value', which represents millions of USD. 'percent' returns data as the percentage of the total fails-to-receive and fails-to-deliver, by asset class. (provider: federal_reserve)
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_primary_dealer_fails_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            asset_class=asset_class,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPrimaryDealerFails",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_primary_dealer_fails_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        asset_class: Annotated[Optional[StrictStr], Field(description="Asset class to return, default is 'all'. (provider: federal_reserve)")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="Unit of the data returned to the 'value' field. Default is 'value', which represents millions of USD. 'percent' returns data as the percentage of the total fails-to-receive and fails-to-deliver, by asset class. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectPrimaryDealerFails]:
        """Primary Dealer Fails

        Primary Dealer Statistics for Fails to Deliver and Fails to Receive.  Data from the NY Federal Reserve are updated on Thursdays at approximately 4:15 p.m. with the previous week's statistics.  For research on the topic, see: https://www.federalreserve.gov/econres/notes/feds-notes/the-systemic-nature-of-settlement-fails-20170703.html  \"Large and protracted settlement fails are believed to undermine the liquidity and well-functioning of securities markets.  Near-100 percent pass-through of fails suggests a high degree of collateral re-hypothecation together with the inability or unwillingness to borrow or buy the needed securities.\"

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param asset_class: Asset class to return, default is 'all'. (provider: federal_reserve)
        :type asset_class: str
        :param unit: Unit of the data returned to the 'value' field. Default is 'value', which represents millions of USD. 'percent' returns data as the percentage of the total fails-to-receive and fails-to-deliver, by asset class. (provider: federal_reserve)
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_primary_dealer_fails_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            asset_class=asset_class,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPrimaryDealerFails",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_primary_dealer_fails_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        asset_class: Annotated[Optional[StrictStr], Field(description="Asset class to return, default is 'all'. (provider: federal_reserve)")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="Unit of the data returned to the 'value' field. Default is 'value', which represents millions of USD. 'percent' returns data as the percentage of the total fails-to-receive and fails-to-deliver, by asset class. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Primary Dealer Fails

        Primary Dealer Statistics for Fails to Deliver and Fails to Receive.  Data from the NY Federal Reserve are updated on Thursdays at approximately 4:15 p.m. with the previous week's statistics.  For research on the topic, see: https://www.federalreserve.gov/econres/notes/feds-notes/the-systemic-nature-of-settlement-fails-20170703.html  \"Large and protracted settlement fails are believed to undermine the liquidity and well-functioning of securities markets.  Near-100 percent pass-through of fails suggests a high degree of collateral re-hypothecation together with the inability or unwillingness to borrow or buy the needed securities.\"

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param asset_class: Asset class to return, default is 'all'. (provider: federal_reserve)
        :type asset_class: str
        :param unit: Unit of the data returned to the 'value' field. Default is 'value', which represents millions of USD. 'percent' returns data as the percentage of the total fails-to-receive and fails-to-deliver, by asset class. (provider: federal_reserve)
        :type unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_primary_dealer_fails_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            asset_class=asset_class,
            unit=unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPrimaryDealerFails",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_primary_dealer_fails_serialize(
        self,
        provider,
        start_date,
        end_date,
        asset_class,
        unit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if asset_class is not None:
            
            _query_params.append(('asset_class', asset_class))
            
        if unit is not None:
            
            _query_params.append(('unit', unit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/primary_dealer_fails',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_primary_dealer_positioning(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category of asset to return, defaults to 'treasuries'. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectPrimaryDealerPositioning:
        """Primary Dealer Positioning

        Get Primary dealer positioning statistics.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param category: The category of asset to return, defaults to 'treasuries'. (provider: federal_reserve)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_primary_dealer_positioning_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPrimaryDealerPositioning",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_primary_dealer_positioning_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category of asset to return, defaults to 'treasuries'. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectPrimaryDealerPositioning]:
        """Primary Dealer Positioning

        Get Primary dealer positioning statistics.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param category: The category of asset to return, defaults to 'treasuries'. (provider: federal_reserve)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_primary_dealer_positioning_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPrimaryDealerPositioning",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_primary_dealer_positioning_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category of asset to return, defaults to 'treasuries'. (provider: federal_reserve)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Primary Dealer Positioning

        Get Primary dealer positioning statistics.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param category: The category of asset to return, defaults to 'treasuries'. (provider: federal_reserve)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_primary_dealer_positioning_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPrimaryDealerPositioning",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_primary_dealer_positioning_serialize(
        self,
        provider,
        start_date,
        end_date,
        category,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/primary_dealer_positioning',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_retail_prices(
        self,
        provider: Optional[StrictStr] = None,
        item: Annotated[Optional[StrictStr], Field(description="The item or basket of items to query.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The region to get average price levels for. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data. (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectRetailPrices:
        """Retail Prices

        Get retail prices for common items.

        :param provider:
        :type provider: str
        :param item: The item or basket of items to query.
        :type item: str
        :param country: The country to get data.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param region: The region to get average price levels for. (provider: fred)
        :type region: str
        :param frequency: The frequency of the data. (provider: fred)
        :type frequency: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_retail_prices_serialize(
            provider=provider,
            item=item,
            country=country,
            start_date=start_date,
            end_date=end_date,
            region=region,
            frequency=frequency,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectRetailPrices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_retail_prices_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        item: Annotated[Optional[StrictStr], Field(description="The item or basket of items to query.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The region to get average price levels for. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data. (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectRetailPrices]:
        """Retail Prices

        Get retail prices for common items.

        :param provider:
        :type provider: str
        :param item: The item or basket of items to query.
        :type item: str
        :param country: The country to get data.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param region: The region to get average price levels for. (provider: fred)
        :type region: str
        :param frequency: The frequency of the data. (provider: fred)
        :type frequency: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_retail_prices_serialize(
            provider=provider,
            item=item,
            country=country,
            start_date=start_date,
            end_date=end_date,
            region=region,
            frequency=frequency,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectRetailPrices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_retail_prices_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        item: Annotated[Optional[StrictStr], Field(description="The item or basket of items to query.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        region: Annotated[Optional[StrictStr], Field(description="The region to get average price levels for. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data. (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Retail Prices

        Get retail prices for common items.

        :param provider:
        :type provider: str
        :param item: The item or basket of items to query.
        :type item: str
        :param country: The country to get data.
        :type country: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param region: The region to get average price levels for. (provider: fred)
        :type region: str
        :param frequency: The frequency of the data. (provider: fred)
        :type frequency: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_retail_prices_serialize(
            provider=provider,
            item=item,
            country=country,
            start_date=start_date,
            end_date=end_date,
            region=region,
            frequency=frequency,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectRetailPrices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_retail_prices_serialize(
        self,
        provider,
        item,
        country,
        start_date,
        end_date,
        region,
        frequency,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if item is not None:
            
            _query_params.append(('item', item))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if region is not None:
            
            _query_params.append(('region', region))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/retail_prices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_risk_premium(
        self,
        provider: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectRiskPremium:
        """Risk Premium

        Get Market Risk Premium by country.

        :param provider:
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_risk_premium_serialize(
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectRiskPremium",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_risk_premium_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectRiskPremium]:
        """Risk Premium

        Get Market Risk Premium by country.

        :param provider:
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_risk_premium_serialize(
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectRiskPremium",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_risk_premium_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Risk Premium

        Get Market Risk Premium by country.

        :param provider:
        :type provider: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_risk_premium_serialize(
            provider=provider,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectRiskPremium",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_risk_premium_serialize(
        self,
        provider,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/risk_premium',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_share_price_index(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSharePriceIndex:
        """Share Price Index

        Get the Share Price Index by country from the OECD Short-Term Economics Statistics.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_share_price_index_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSharePriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_share_price_index_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSharePriceIndex]:
        """Share Price Index

        Get the Share Price Index by country from the OECD Short-Term Economics Statistics.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_share_price_index_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSharePriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_share_price_index_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Share Price Index

        Get the Share Price Index by country from the OECD Short-Term Economics Statistics.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_share_price_index_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSharePriceIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_share_price_index_serialize(
        self,
        provider,
        country,
        frequency,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/share_price_index',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_short_term_interest_rate(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country to get interest rate for. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSTIR:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get Short-term interest rates.  They are the rates at which short-term borrowings are effected between financial institutions or the rate at which short-term government paper is issued or traded in the market.  Short-term interest rates are generally averages of daily rates, measured as a percentage. Short-term interest rates are based on three-month money market rates where available. Typical standardised names are \"money market rate\" and \"treasury bill rate\".

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get interest rate for. (provider: oecd)
        :type country: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/short_term_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_short_term_interest_rate_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSTIR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_short_term_interest_rate_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country to get interest rate for. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSTIR]:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get Short-term interest rates.  They are the rates at which short-term borrowings are effected between financial institutions or the rate at which short-term government paper is issued or traded in the market.  Short-term interest rates are generally averages of daily rates, measured as a percentage. Short-term interest rates are based on three-month money market rates where available. Typical standardised names are \"money market rate\" and \"treasury bill rate\".

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get interest rate for. (provider: oecd)
        :type country: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/short_term_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_short_term_interest_rate_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSTIR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_short_term_interest_rate_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="Country to get interest rate for. (provider: oecd)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency to get interest rate for for. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/economy/interest_rates`, instead. Deprecated in OpenBB Platform V4.3 to be removed in V4.5.

        Get Short-term interest rates.  They are the rates at which short-term borrowings are effected between financial institutions or the rate at which short-term government paper is issued or traded in the market.  Short-term interest rates are generally averages of daily rates, measured as a percentage. Short-term interest rates are based on three-month money market rates where available. Typical standardised names are \"money market rate\" and \"treasury bill rate\".

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param country: Country to get interest rate for. (provider: oecd)
        :type country: str
        :param frequency: Frequency to get interest rate for for. (provider: oecd)
        :type frequency: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/economy/short_term_interest_rate is deprecated.", DeprecationWarning)

        _param = self._economy_short_term_interest_rate_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            country=country,
            frequency=frequency,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSTIR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_short_term_interest_rate_serialize(
        self,
        provider,
        start_date,
        end_date,
        country,
        frequency,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/short_term_interest_rate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_survey_bls_search(
        self,
        provider: Optional[StrictStr] = None,
        query: Annotated[Optional[StrictStr], Field(description="The search word(s). Use semi-colon to separate multiple queries as an & operator.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category of BLS survey to search within.         An empty search query will return all series within the category. Options are:              cpi - Consumer Price Index              pce - Personal Consumption Expenditure              ppi - Producer Price Index              ip - Industry Productivity              jolts - Job Openings and Labor Turnover Survey              nfp - Nonfarm Payrolls              cps - Current Population Survey              lfs - Labor Force Statistics              wages - Wages              ec - Employer Costs              sla - State and Local Area Employment              bed - Business Employment Dynamics              tu - Time Use          (provider: bls)")] = None,
        include_extras: Annotated[Optional[StrictBool], Field(description="Include additional information in the search results. Extra fields returned are metadata and vary by survey. Fields are undefined strings that typically have names ending with '_code'. (provider: bls)")] = None,
        include_code_map: Annotated[Optional[StrictBool], Field(description="When True, includes the complete code map for eah survey in the category, returned separately as a nested JSON to the `extras['results_metadata']` property of the response. Example content is the NAICS industry map for PPI surveys. Each code is a value within the 'symbol' of the time series. (provider: bls)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectBlsSearch:
        """Bls Search

        Search BLS surveys by category and keyword or phrase to identify BLS series IDs.

        :param provider:
        :type provider: str
        :param query: The search word(s). Use semi-colon to separate multiple queries as an & operator.
        :type query: str
        :param category: The category of BLS survey to search within.         An empty search query will return all series within the category. Options are:              cpi - Consumer Price Index              pce - Personal Consumption Expenditure              ppi - Producer Price Index              ip - Industry Productivity              jolts - Job Openings and Labor Turnover Survey              nfp - Nonfarm Payrolls              cps - Current Population Survey              lfs - Labor Force Statistics              wages - Wages              ec - Employer Costs              sla - State and Local Area Employment              bed - Business Employment Dynamics              tu - Time Use          (provider: bls)
        :type category: str
        :param include_extras: Include additional information in the search results. Extra fields returned are metadata and vary by survey. Fields are undefined strings that typically have names ending with '_code'. (provider: bls)
        :type include_extras: bool
        :param include_code_map: When True, includes the complete code map for eah survey in the category, returned separately as a nested JSON to the `extras['results_metadata']` property of the response. Example content is the NAICS industry map for PPI surveys. Each code is a value within the 'symbol' of the time series. (provider: bls)
        :type include_code_map: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_bls_search_serialize(
            provider=provider,
            query=query,
            category=category,
            include_extras=include_extras,
            include_code_map=include_code_map,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBlsSearch",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_survey_bls_search_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        query: Annotated[Optional[StrictStr], Field(description="The search word(s). Use semi-colon to separate multiple queries as an & operator.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category of BLS survey to search within.         An empty search query will return all series within the category. Options are:              cpi - Consumer Price Index              pce - Personal Consumption Expenditure              ppi - Producer Price Index              ip - Industry Productivity              jolts - Job Openings and Labor Turnover Survey              nfp - Nonfarm Payrolls              cps - Current Population Survey              lfs - Labor Force Statistics              wages - Wages              ec - Employer Costs              sla - State and Local Area Employment              bed - Business Employment Dynamics              tu - Time Use          (provider: bls)")] = None,
        include_extras: Annotated[Optional[StrictBool], Field(description="Include additional information in the search results. Extra fields returned are metadata and vary by survey. Fields are undefined strings that typically have names ending with '_code'. (provider: bls)")] = None,
        include_code_map: Annotated[Optional[StrictBool], Field(description="When True, includes the complete code map for eah survey in the category, returned separately as a nested JSON to the `extras['results_metadata']` property of the response. Example content is the NAICS industry map for PPI surveys. Each code is a value within the 'symbol' of the time series. (provider: bls)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectBlsSearch]:
        """Bls Search

        Search BLS surveys by category and keyword or phrase to identify BLS series IDs.

        :param provider:
        :type provider: str
        :param query: The search word(s). Use semi-colon to separate multiple queries as an & operator.
        :type query: str
        :param category: The category of BLS survey to search within.         An empty search query will return all series within the category. Options are:              cpi - Consumer Price Index              pce - Personal Consumption Expenditure              ppi - Producer Price Index              ip - Industry Productivity              jolts - Job Openings and Labor Turnover Survey              nfp - Nonfarm Payrolls              cps - Current Population Survey              lfs - Labor Force Statistics              wages - Wages              ec - Employer Costs              sla - State and Local Area Employment              bed - Business Employment Dynamics              tu - Time Use          (provider: bls)
        :type category: str
        :param include_extras: Include additional information in the search results. Extra fields returned are metadata and vary by survey. Fields are undefined strings that typically have names ending with '_code'. (provider: bls)
        :type include_extras: bool
        :param include_code_map: When True, includes the complete code map for eah survey in the category, returned separately as a nested JSON to the `extras['results_metadata']` property of the response. Example content is the NAICS industry map for PPI surveys. Each code is a value within the 'symbol' of the time series. (provider: bls)
        :type include_code_map: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_bls_search_serialize(
            provider=provider,
            query=query,
            category=category,
            include_extras=include_extras,
            include_code_map=include_code_map,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBlsSearch",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_survey_bls_search_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        query: Annotated[Optional[StrictStr], Field(description="The search word(s). Use semi-colon to separate multiple queries as an & operator.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category of BLS survey to search within.         An empty search query will return all series within the category. Options are:              cpi - Consumer Price Index              pce - Personal Consumption Expenditure              ppi - Producer Price Index              ip - Industry Productivity              jolts - Job Openings and Labor Turnover Survey              nfp - Nonfarm Payrolls              cps - Current Population Survey              lfs - Labor Force Statistics              wages - Wages              ec - Employer Costs              sla - State and Local Area Employment              bed - Business Employment Dynamics              tu - Time Use          (provider: bls)")] = None,
        include_extras: Annotated[Optional[StrictBool], Field(description="Include additional information in the search results. Extra fields returned are metadata and vary by survey. Fields are undefined strings that typically have names ending with '_code'. (provider: bls)")] = None,
        include_code_map: Annotated[Optional[StrictBool], Field(description="When True, includes the complete code map for eah survey in the category, returned separately as a nested JSON to the `extras['results_metadata']` property of the response. Example content is the NAICS industry map for PPI surveys. Each code is a value within the 'symbol' of the time series. (provider: bls)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Bls Search

        Search BLS surveys by category and keyword or phrase to identify BLS series IDs.

        :param provider:
        :type provider: str
        :param query: The search word(s). Use semi-colon to separate multiple queries as an & operator.
        :type query: str
        :param category: The category of BLS survey to search within.         An empty search query will return all series within the category. Options are:              cpi - Consumer Price Index              pce - Personal Consumption Expenditure              ppi - Producer Price Index              ip - Industry Productivity              jolts - Job Openings and Labor Turnover Survey              nfp - Nonfarm Payrolls              cps - Current Population Survey              lfs - Labor Force Statistics              wages - Wages              ec - Employer Costs              sla - State and Local Area Employment              bed - Business Employment Dynamics              tu - Time Use          (provider: bls)
        :type category: str
        :param include_extras: Include additional information in the search results. Extra fields returned are metadata and vary by survey. Fields are undefined strings that typically have names ending with '_code'. (provider: bls)
        :type include_extras: bool
        :param include_code_map: When True, includes the complete code map for eah survey in the category, returned separately as a nested JSON to the `extras['results_metadata']` property of the response. Example content is the NAICS industry map for PPI surveys. Each code is a value within the 'symbol' of the time series. (provider: bls)
        :type include_code_map: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_bls_search_serialize(
            provider=provider,
            query=query,
            category=category,
            include_extras=include_extras,
            include_code_map=include_code_map,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBlsSearch",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_survey_bls_search_serialize(
        self,
        provider,
        query,
        category,
        include_extras,
        include_code_map,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if include_extras is not None:
            
            _query_params.append(('include_extras', include_extras))
            
        if include_code_map is not None:
            
            _query_params.append(('include_code_map', include_code_map))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/survey/bls_search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_survey_bls_series(
        self,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for. Multiple comma separated items allowed for provider(s): bls.")],
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        calculations: Annotated[Optional[StrictBool], Field(description="Include calculations in the response, if available. Default is True. (provider: bls)")] = None,
        annual_average: Annotated[Optional[StrictBool], Field(description="Include annual averages in the response, if available. Default is False. (provider: bls)")] = None,
        aspects: Annotated[Optional[StrictBool], Field(description="Include all aspects associated with a data point for a given BLS series ID, if available. Returned with the series metadata, under `extras` of the response object. Default is False. (provider: bls)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectBlsSeries:
        """Bls Series

        Get time series data for one, or more, BLS series IDs.

        :param symbol: Symbol to get data for. Multiple comma separated items allowed for provider(s): bls. (required)
        :type symbol: str
        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param calculations: Include calculations in the response, if available. Default is True. (provider: bls)
        :type calculations: bool
        :param annual_average: Include annual averages in the response, if available. Default is False. (provider: bls)
        :type annual_average: bool
        :param aspects: Include all aspects associated with a data point for a given BLS series ID, if available. Returned with the series metadata, under `extras` of the response object. Default is False. (provider: bls)
        :type aspects: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_bls_series_serialize(
            symbol=symbol,
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            calculations=calculations,
            annual_average=annual_average,
            aspects=aspects,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBlsSeries",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_survey_bls_series_with_http_info(
        self,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for. Multiple comma separated items allowed for provider(s): bls.")],
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        calculations: Annotated[Optional[StrictBool], Field(description="Include calculations in the response, if available. Default is True. (provider: bls)")] = None,
        annual_average: Annotated[Optional[StrictBool], Field(description="Include annual averages in the response, if available. Default is False. (provider: bls)")] = None,
        aspects: Annotated[Optional[StrictBool], Field(description="Include all aspects associated with a data point for a given BLS series ID, if available. Returned with the series metadata, under `extras` of the response object. Default is False. (provider: bls)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectBlsSeries]:
        """Bls Series

        Get time series data for one, or more, BLS series IDs.

        :param symbol: Symbol to get data for. Multiple comma separated items allowed for provider(s): bls. (required)
        :type symbol: str
        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param calculations: Include calculations in the response, if available. Default is True. (provider: bls)
        :type calculations: bool
        :param annual_average: Include annual averages in the response, if available. Default is False. (provider: bls)
        :type annual_average: bool
        :param aspects: Include all aspects associated with a data point for a given BLS series ID, if available. Returned with the series metadata, under `extras` of the response object. Default is False. (provider: bls)
        :type aspects: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_bls_series_serialize(
            symbol=symbol,
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            calculations=calculations,
            annual_average=annual_average,
            aspects=aspects,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBlsSeries",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_survey_bls_series_without_preload_content(
        self,
        symbol: Annotated[StrictStr, Field(description="Symbol to get data for. Multiple comma separated items allowed for provider(s): bls.")],
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        calculations: Annotated[Optional[StrictBool], Field(description="Include calculations in the response, if available. Default is True. (provider: bls)")] = None,
        annual_average: Annotated[Optional[StrictBool], Field(description="Include annual averages in the response, if available. Default is False. (provider: bls)")] = None,
        aspects: Annotated[Optional[StrictBool], Field(description="Include all aspects associated with a data point for a given BLS series ID, if available. Returned with the series metadata, under `extras` of the response object. Default is False. (provider: bls)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Bls Series

        Get time series data for one, or more, BLS series IDs.

        :param symbol: Symbol to get data for. Multiple comma separated items allowed for provider(s): bls. (required)
        :type symbol: str
        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param calculations: Include calculations in the response, if available. Default is True. (provider: bls)
        :type calculations: bool
        :param annual_average: Include annual averages in the response, if available. Default is False. (provider: bls)
        :type annual_average: bool
        :param aspects: Include all aspects associated with a data point for a given BLS series ID, if available. Returned with the series metadata, under `extras` of the response object. Default is False. (provider: bls)
        :type aspects: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_bls_series_serialize(
            symbol=symbol,
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            calculations=calculations,
            annual_average=annual_average,
            aspects=aspects,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBlsSeries",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_survey_bls_series_serialize(
        self,
        symbol,
        provider,
        start_date,
        end_date,
        calculations,
        annual_average,
        aspects,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if symbol is not None:
            
            _query_params.append(('symbol', symbol))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if calculations is not None:
            
            _query_params.append(('calculations', calculations))
            
        if annual_average is not None:
            
            _query_params.append(('annual_average', annual_average))
            
        if aspects is not None:
            
            _query_params.append(('aspects', aspects))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/survey/bls_series',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_survey_economic_conditions_chicago(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSurveyOfEconomicConditionsChicago:
        """Economic Conditions Chicago

        Get The Survey Of Economic Conditions For The Chicago Region.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_economic_conditions_chicago_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSurveyOfEconomicConditionsChicago",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_survey_economic_conditions_chicago_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSurveyOfEconomicConditionsChicago]:
        """Economic Conditions Chicago

        Get The Survey Of Economic Conditions For The Chicago Region.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_economic_conditions_chicago_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSurveyOfEconomicConditionsChicago",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_survey_economic_conditions_chicago_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Economic Conditions Chicago

        Get The Survey Of Economic Conditions For The Chicago Region.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_economic_conditions_chicago_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSurveyOfEconomicConditionsChicago",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_survey_economic_conditions_chicago_serialize(
        self,
        provider,
        start_date,
        end_date,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/survey/economic_conditions_chicago',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_survey_manufacturing_outlook_texas(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        topic: Annotated[Optional[Any], Field(description="The topic for the survey response. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert monthly data to lower frequency. None is monthly.          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectManufacturingOutlookTexas:
        """Manufacturing Outlook Texas

        Get The Manufacturing Outlook Survey For The Texas Region.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param topic: The topic for the survey response. Multiple comma separated items allowed. (provider: fred)
        :type topic: Fred
        :param frequency:          Frequency aggregation to convert monthly data to lower frequency. None is monthly.          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_manufacturing_outlook_texas_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            topic=topic,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectManufacturingOutlookTexas",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_survey_manufacturing_outlook_texas_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        topic: Annotated[Optional[Any], Field(description="The topic for the survey response. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert monthly data to lower frequency. None is monthly.          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectManufacturingOutlookTexas]:
        """Manufacturing Outlook Texas

        Get The Manufacturing Outlook Survey For The Texas Region.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param topic: The topic for the survey response. Multiple comma separated items allowed. (provider: fred)
        :type topic: Fred
        :param frequency:          Frequency aggregation to convert monthly data to lower frequency. None is monthly.          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_manufacturing_outlook_texas_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            topic=topic,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectManufacturingOutlookTexas",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_survey_manufacturing_outlook_texas_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        topic: Annotated[Optional[Any], Field(description="The topic for the survey response. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert monthly data to lower frequency. None is monthly.          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Manufacturing Outlook Texas

        Get The Manufacturing Outlook Survey For The Texas Region.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param topic: The topic for the survey response. Multiple comma separated items allowed. (provider: fred)
        :type topic: Fred
        :param frequency:          Frequency aggregation to convert monthly data to lower frequency. None is monthly.          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_manufacturing_outlook_texas_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            topic=topic,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectManufacturingOutlookTexas",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_survey_manufacturing_outlook_texas_serialize(
        self,
        provider,
        start_date,
        end_date,
        topic,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if topic is not None:
            
            _query_params.append(('topic', topic))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/survey/manufacturing_outlook_texas',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_survey_nonfarm_payrolls(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category to query. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectNonFarmPayrolls:
        """Nonfarm Payrolls

        Get Nonfarm Payrolls Survey.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date1
        :param category: The category to query. (provider: fred)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_nonfarm_payrolls_serialize(
            provider=provider,
            var_date=var_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectNonFarmPayrolls",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_survey_nonfarm_payrolls_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category to query. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectNonFarmPayrolls]:
        """Nonfarm Payrolls

        Get Nonfarm Payrolls Survey.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date1
        :param category: The category to query. (provider: fred)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_nonfarm_payrolls_serialize(
            provider=provider,
            var_date=var_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectNonFarmPayrolls",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_survey_nonfarm_payrolls_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The category to query. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Nonfarm Payrolls

        Get Nonfarm Payrolls Survey.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Default is the latest report. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date1
        :param category: The category to query. (provider: fred)
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_nonfarm_payrolls_serialize(
            provider=provider,
            var_date=var_date,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectNonFarmPayrolls",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_survey_nonfarm_payrolls_serialize(
        self,
        provider,
        var_date,
        category,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/survey/nonfarm_payrolls',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_survey_sloos(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category of survey response. (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSeniorLoanOfficerSurvey:
        """Sloos

        Get Senior Loan Officers Opinion Survey.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param category: Category of survey response. (provider: fred)
        :type category: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_sloos_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            category=category,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSeniorLoanOfficerSurvey",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_survey_sloos_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category of survey response. (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSeniorLoanOfficerSurvey]:
        """Sloos

        Get Senior Loan Officers Opinion Survey.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param category: Category of survey response. (provider: fred)
        :type category: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_sloos_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            category=category,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSeniorLoanOfficerSurvey",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_survey_sloos_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Category of survey response. (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sloos

        Get Senior Loan Officers Opinion Survey.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param category: Category of survey response. (provider: fred)
        :type category: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_sloos_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            category=category,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSeniorLoanOfficerSurvey",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_survey_sloos_serialize(
        self,
        provider,
        start_date,
        end_date,
        category,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/survey/sloos',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_survey_university_of_michigan(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectUniversityOfMichigan:
        """University Of Michigan

        Get University of Michigan Consumer Sentiment and Inflation Expectations Surveys.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_university_of_michigan_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUniversityOfMichigan",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_survey_university_of_michigan_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectUniversityOfMichigan]:
        """University Of Michigan

        Get University of Michigan Consumer Sentiment and Inflation Expectations Surveys.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_university_of_michigan_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUniversityOfMichigan",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_survey_university_of_michigan_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """University Of Michigan

        Get University of Michigan Consumer Sentiment and Inflation Expectations Surveys.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert monthly data to lower frequency. None is monthly. (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_survey_university_of_michigan_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUniversityOfMichigan",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_survey_university_of_michigan_serialize(
        self,
        provider,
        start_date,
        end_date,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/survey/university_of_michigan',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def economy_unemployment(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Sex to get unemployment for. (provider: oecd)")] = None,
        age: Annotated[Optional[StrictStr], Field(description="Age group to get unemployment for. Total indicates 15 years or over (provider: oecd)")] = None,
        seasonal_adjustment: Annotated[Optional[StrictBool], Field(description="Whether to get seasonally adjusted unemployment. Defaults to False. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectUnemployment:
        """Unemployment

        Get global unemployment data.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param sex: Sex to get unemployment for. (provider: oecd)
        :type sex: str
        :param age: Age group to get unemployment for. Total indicates 15 years or over (provider: oecd)
        :type age: str
        :param seasonal_adjustment: Whether to get seasonally adjusted unemployment. Defaults to False. (provider: oecd)
        :type seasonal_adjustment: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_unemployment_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            start_date=start_date,
            end_date=end_date,
            sex=sex,
            age=age,
            seasonal_adjustment=seasonal_adjustment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUnemployment",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def economy_unemployment_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Sex to get unemployment for. (provider: oecd)")] = None,
        age: Annotated[Optional[StrictStr], Field(description="Age group to get unemployment for. Total indicates 15 years or over (provider: oecd)")] = None,
        seasonal_adjustment: Annotated[Optional[StrictBool], Field(description="Whether to get seasonally adjusted unemployment. Defaults to False. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectUnemployment]:
        """Unemployment

        Get global unemployment data.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param sex: Sex to get unemployment for. (provider: oecd)
        :type sex: str
        :param age: Age group to get unemployment for. Total indicates 15 years or over (provider: oecd)
        :type age: str
        :param seasonal_adjustment: Whether to get seasonally adjusted unemployment. Defaults to False. (provider: oecd)
        :type seasonal_adjustment: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_unemployment_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            start_date=start_date,
            end_date=end_date,
            sex=sex,
            age=age,
            seasonal_adjustment=seasonal_adjustment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUnemployment",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def economy_unemployment_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. Multiple comma separated items allowed for provider(s): oecd.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="The frequency of the data.")] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        sex: Annotated[Optional[StrictStr], Field(description="Sex to get unemployment for. (provider: oecd)")] = None,
        age: Annotated[Optional[StrictStr], Field(description="Age group to get unemployment for. Total indicates 15 years or over (provider: oecd)")] = None,
        seasonal_adjustment: Annotated[Optional[StrictBool], Field(description="Whether to get seasonally adjusted unemployment. Defaults to False. (provider: oecd)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Unemployment

        Get global unemployment data.

        :param provider:
        :type provider: str
        :param country: The country to get data. Multiple comma separated items allowed for provider(s): oecd.
        :type country: str
        :param frequency: The frequency of the data.
        :type frequency: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param sex: Sex to get unemployment for. (provider: oecd)
        :type sex: str
        :param age: Age group to get unemployment for. Total indicates 15 years or over (provider: oecd)
        :type age: str
        :param seasonal_adjustment: Whether to get seasonally adjusted unemployment. Defaults to False. (provider: oecd)
        :type seasonal_adjustment: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._economy_unemployment_serialize(
            provider=provider,
            country=country,
            frequency=frequency,
            start_date=start_date,
            end_date=end_date,
            sex=sex,
            age=age,
            seasonal_adjustment=seasonal_adjustment,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUnemployment",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _economy_unemployment_serialize(
        self,
        provider,
        country,
        frequency,
        start_date,
        end_date,
        sex,
        age,
        seasonal_adjustment,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if sex is not None:
            
            _query_params.append(('sex', sex))
            
        if age is not None:
            
            _query_params.append(('age', age))
            
        if seasonal_adjustment is not None:
            
            _query_params.append(('seasonal_adjustment', seasonal_adjustment))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/economy/unemployment',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


