# coding: utf-8

"""
    OpenBB Platform API

    Investment research for everyone, anywhere.

    The version of the OpenAPI document: 1
    Contact: hello@openbb.co
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import date
from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, Optional
from typing_extensions import Annotated
from openbb_client.models.ob_bject_ameribor import OBBjectAmeribor
from openbb_client.models.ob_bject_bond_indices import OBBjectBondIndices
from openbb_client.models.ob_bject_commercial_paper import OBBjectCommercialPaper
from openbb_client.models.ob_bject_discount_window_primary_credit_rate import OBBjectDiscountWindowPrimaryCreditRate
from openbb_client.models.ob_bject_euro_short_term_rate import OBBjectEuroShortTermRate
from openbb_client.models.ob_bject_european_central_bank_interest_rates import OBBjectEuropeanCentralBankInterestRates
from openbb_client.models.ob_bject_federal_funds_rate import OBBjectFederalFundsRate
from openbb_client.models.ob_bject_high_quality_market_corporate_bond import OBBjectHighQualityMarketCorporateBond
from openbb_client.models.ob_bject_ice_bof_a import OBBjectICEBofA
from openbb_client.models.ob_bject_iorb import OBBjectIORB
from openbb_client.models.ob_bject_moody_corporate_bond_index import OBBjectMoodyCorporateBondIndex
from openbb_client.models.ob_bject_mortgage_indices import OBBjectMortgageIndices
from openbb_client.models.ob_bject_overnight_bank_funding_rate import OBBjectOvernightBankFundingRate
from openbb_client.models.ob_bject_projections import OBBjectPROJECTIONS
from openbb_client.models.ob_bject_sofr import OBBjectSOFR
from openbb_client.models.ob_bject_sonia import OBBjectSONIA
from openbb_client.models.ob_bject_selected_treasury_bill import OBBjectSelectedTreasuryBill
from openbb_client.models.ob_bject_selected_treasury_constant_maturity import OBBjectSelectedTreasuryConstantMaturity
from openbb_client.models.ob_bject_spot_rate import OBBjectSpotRate
from openbb_client.models.ob_bject_tips_yields import OBBjectTipsYields
from openbb_client.models.ob_bject_treasury_constant_maturity import OBBjectTreasuryConstantMaturity
from openbb_client.models.ob_bject_treasury_rates import OBBjectTreasuryRates
from openbb_client.models.ob_bject_us_yield_curve import OBBjectUSYieldCurve
from openbb_client.models.ob_bject_yield_curve import OBBjectYieldCurve

from openbb_client.api_client import ApiClient, RequestSerialized
from openbb_client.api_response import ApiResponse
from openbb_client.rest import RESTResponseType


class FixedincomeApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def fixedincome_bond_indices(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series. OAS is the option-adjusted spread. Default is yield.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The type of index category. Used in conjunction with 'index', default is 'us'. (provider: fred)")] = None,
        index: Annotated[Optional[StrictStr], Field(description="The specific index to query. Used in conjunction with 'category' and 'index_type', default is 'yield_curve'. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectBondIndices:
        """Bond Indices

        Bond Indices.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series. OAS is the option-adjusted spread. Default is yield.
        :type index_type: str
        :param category: The type of index category. Used in conjunction with 'index', default is 'us'. (provider: fred)
        :type category: str
        :param index: The specific index to query. Used in conjunction with 'category' and 'index_type', default is 'yield_curve'. Multiple comma separated items allowed. (provider: fred)
        :type index: str
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_bond_indices_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            category=category,
            index=index,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBondIndices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_bond_indices_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series. OAS is the option-adjusted spread. Default is yield.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The type of index category. Used in conjunction with 'index', default is 'us'. (provider: fred)")] = None,
        index: Annotated[Optional[StrictStr], Field(description="The specific index to query. Used in conjunction with 'category' and 'index_type', default is 'yield_curve'. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectBondIndices]:
        """Bond Indices

        Bond Indices.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series. OAS is the option-adjusted spread. Default is yield.
        :type index_type: str
        :param category: The type of index category. Used in conjunction with 'index', default is 'us'. (provider: fred)
        :type category: str
        :param index: The specific index to query. Used in conjunction with 'category' and 'index_type', default is 'yield_curve'. Multiple comma separated items allowed. (provider: fred)
        :type index: str
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_bond_indices_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            category=category,
            index=index,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBondIndices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_bond_indices_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series. OAS is the option-adjusted spread. Default is yield.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The type of index category. Used in conjunction with 'index', default is 'us'. (provider: fred)")] = None,
        index: Annotated[Optional[StrictStr], Field(description="The specific index to query. Used in conjunction with 'category' and 'index_type', default is 'yield_curve'. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Bond Indices

        Bond Indices.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series. OAS is the option-adjusted spread. Default is yield.
        :type index_type: str
        :param category: The type of index category. Used in conjunction with 'index', default is 'us'. (provider: fred)
        :type category: str
        :param index: The specific index to query. Used in conjunction with 'category' and 'index_type', default is 'yield_curve'. Multiple comma separated items allowed. (provider: fred)
        :type index: str
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_bond_indices_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            category=category,
            index=index,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectBondIndices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_bond_indices_serialize(
        self,
        provider,
        start_date,
        end_date,
        index_type,
        category,
        index,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if index_type is not None:
            
            _query_params.append(('index_type', index_type))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if index is not None:
            
            _query_params.append(('index', index))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/bond_indices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_corporate_commercial_paper(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="A target maturity. Multiple comma separated items allowed. (provider: fred)")] = None,
        category: Annotated[Optional[Any], Field(description="The category of asset. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectCommercialPaper:
        """Commercial Paper

        Commercial Paper.  Commercial paper (CP) consists of short-term, promissory notes issued primarily by corporations. Maturities range up to 270 days but average about 30 days. Many companies use CP to raise cash needed for current transactions, and many find it to be a lower-cost alternative to bank loans.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: A target maturity. Multiple comma separated items allowed. (provider: fred)
        :type maturity: Fred2
        :param category: The category of asset. Multiple comma separated items allowed. (provider: fred)
        :type category: Fred3
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_commercial_paper_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            category=category,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCommercialPaper",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_corporate_commercial_paper_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="A target maturity. Multiple comma separated items allowed. (provider: fred)")] = None,
        category: Annotated[Optional[Any], Field(description="The category of asset. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectCommercialPaper]:
        """Commercial Paper

        Commercial Paper.  Commercial paper (CP) consists of short-term, promissory notes issued primarily by corporations. Maturities range up to 270 days but average about 30 days. Many companies use CP to raise cash needed for current transactions, and many find it to be a lower-cost alternative to bank loans.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: A target maturity. Multiple comma separated items allowed. (provider: fred)
        :type maturity: Fred2
        :param category: The category of asset. Multiple comma separated items allowed. (provider: fred)
        :type category: Fred3
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_commercial_paper_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            category=category,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCommercialPaper",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_corporate_commercial_paper_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="A target maturity. Multiple comma separated items allowed. (provider: fred)")] = None,
        category: Annotated[Optional[Any], Field(description="The category of asset. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Commercial Paper

        Commercial Paper.  Commercial paper (CP) consists of short-term, promissory notes issued primarily by corporations. Maturities range up to 270 days but average about 30 days. Many companies use CP to raise cash needed for current transactions, and many find it to be a lower-cost alternative to bank loans.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: A target maturity. Multiple comma separated items allowed. (provider: fred)
        :type maturity: Fred2
        :param category: The category of asset. Multiple comma separated items allowed. (provider: fred)
        :type category: Fred3
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_commercial_paper_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            category=category,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectCommercialPaper",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_corporate_commercial_paper_serialize(
        self,
        provider,
        start_date,
        end_date,
        maturity,
        category,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if maturity is not None:
            
            _query_params.append(('maturity', maturity))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/corporate/commercial_paper',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_corporate_hqm(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.")] = None,
        yield_curve: Annotated[Optional[StrictStr], Field(description="The yield curve type. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectHighQualityMarketCorporateBond:
        """Hqm

        High Quality Market Corporate Bond.  The HQM yield curve represents the high quality corporate bond market, i.e., corporate bonds rated AAA, AA, or A.  The HQM curve contains two regression terms. These terms are adjustment factors that blend AAA, AA, and A bonds into a single HQM yield curve that is the market-weighted average (MWA) quality of high quality bonds.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date5
        :param yield_curve: The yield curve type. (provider: fred)
        :type yield_curve: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_hqm_serialize(
            provider=provider,
            var_date=var_date,
            yield_curve=yield_curve,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectHighQualityMarketCorporateBond",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_corporate_hqm_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.")] = None,
        yield_curve: Annotated[Optional[StrictStr], Field(description="The yield curve type. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectHighQualityMarketCorporateBond]:
        """Hqm

        High Quality Market Corporate Bond.  The HQM yield curve represents the high quality corporate bond market, i.e., corporate bonds rated AAA, AA, or A.  The HQM curve contains two regression terms. These terms are adjustment factors that blend AAA, AA, and A bonds into a single HQM yield curve that is the market-weighted average (MWA) quality of high quality bonds.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date5
        :param yield_curve: The yield curve type. (provider: fred)
        :type yield_curve: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_hqm_serialize(
            provider=provider,
            var_date=var_date,
            yield_curve=yield_curve,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectHighQualityMarketCorporateBond",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_corporate_hqm_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.")] = None,
        yield_curve: Annotated[Optional[StrictStr], Field(description="The yield curve type. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Hqm

        High Quality Market Corporate Bond.  The HQM yield curve represents the high quality corporate bond market, i.e., corporate bonds rated AAA, AA, or A.  The HQM curve contains two regression terms. These terms are adjustment factors that blend AAA, AA, and A bonds into a single HQM yield curve that is the market-weighted average (MWA) quality of high quality bonds.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Multiple comma separated items allowed for provider(s): fred.
        :type var_date: Date5
        :param yield_curve: The yield curve type. (provider: fred)
        :type yield_curve: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_hqm_serialize(
            provider=provider,
            var_date=var_date,
            yield_curve=yield_curve,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectHighQualityMarketCorporateBond",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_corporate_hqm_serialize(
        self,
        provider,
        var_date,
        yield_curve,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if yield_curve is not None:
            
            _query_params.append(('yield_curve', yield_curve))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/corporate/hqm',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_corporate_ice_bofa(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The type of category. (provider: fred)")] = None,
        area: Annotated[Optional[StrictStr], Field(description="The type of area. (provider: fred)")] = None,
        grade: Annotated[Optional[StrictStr], Field(description="The type of grade. (provider: fred)")] = None,
        options: Annotated[Optional[StrictBool], Field(description="Whether to include options in the results. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectICEBofA:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/bond_indices` instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        ICE BofA US Corporate Bond Indices.  The ICE BofA US Corporate Index tracks the performance of US dollar denominated investment grade corporate debt publicly issued in the US domestic market. Qualifying securities must have an investment grade rating (based on an average of Moodys, S&P and Fitch), at least 18 months to final maturity at the time of issuance, at least one year remaining term to final maturity as of the rebalance date, a fixed coupon schedule and a minimum amount outstanding of $250 million. The ICE BofA US Corporate Index is a component of the US Corporate Master Index.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series.
        :type index_type: str
        :param category: The type of category. (provider: fred)
        :type category: str
        :param area: The type of area. (provider: fred)
        :type area: str
        :param grade: The type of grade. (provider: fred)
        :type grade: str
        :param options: Whether to include options in the results. (provider: fred)
        :type options: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/corporate/ice_bofa is deprecated.", DeprecationWarning)

        _param = self._fixedincome_corporate_ice_bofa_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            category=category,
            area=area,
            grade=grade,
            options=options,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectICEBofA",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_corporate_ice_bofa_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The type of category. (provider: fred)")] = None,
        area: Annotated[Optional[StrictStr], Field(description="The type of area. (provider: fred)")] = None,
        grade: Annotated[Optional[StrictStr], Field(description="The type of grade. (provider: fred)")] = None,
        options: Annotated[Optional[StrictBool], Field(description="Whether to include options in the results. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectICEBofA]:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/bond_indices` instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        ICE BofA US Corporate Bond Indices.  The ICE BofA US Corporate Index tracks the performance of US dollar denominated investment grade corporate debt publicly issued in the US domestic market. Qualifying securities must have an investment grade rating (based on an average of Moodys, S&P and Fitch), at least 18 months to final maturity at the time of issuance, at least one year remaining term to final maturity as of the rebalance date, a fixed coupon schedule and a minimum amount outstanding of $250 million. The ICE BofA US Corporate Index is a component of the US Corporate Master Index.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series.
        :type index_type: str
        :param category: The type of category. (provider: fred)
        :type category: str
        :param area: The type of area. (provider: fred)
        :type area: str
        :param grade: The type of grade. (provider: fred)
        :type grade: str
        :param options: Whether to include options in the results. (provider: fred)
        :type options: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/corporate/ice_bofa is deprecated.", DeprecationWarning)

        _param = self._fixedincome_corporate_ice_bofa_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            category=category,
            area=area,
            grade=grade,
            options=options,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectICEBofA",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_corporate_ice_bofa_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="The type of category. (provider: fred)")] = None,
        area: Annotated[Optional[StrictStr], Field(description="The type of area. (provider: fred)")] = None,
        grade: Annotated[Optional[StrictStr], Field(description="The type of grade. (provider: fred)")] = None,
        options: Annotated[Optional[StrictBool], Field(description="Whether to include options in the results. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/bond_indices` instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        ICE BofA US Corporate Bond Indices.  The ICE BofA US Corporate Index tracks the performance of US dollar denominated investment grade corporate debt publicly issued in the US domestic market. Qualifying securities must have an investment grade rating (based on an average of Moodys, S&P and Fitch), at least 18 months to final maturity at the time of issuance, at least one year remaining term to final maturity as of the rebalance date, a fixed coupon schedule and a minimum amount outstanding of $250 million. The ICE BofA US Corporate Index is a component of the US Corporate Master Index.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series.
        :type index_type: str
        :param category: The type of category. (provider: fred)
        :type category: str
        :param area: The type of area. (provider: fred)
        :type area: str
        :param grade: The type of grade. (provider: fred)
        :type grade: str
        :param options: Whether to include options in the results. (provider: fred)
        :type options: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/corporate/ice_bofa is deprecated.", DeprecationWarning)

        _param = self._fixedincome_corporate_ice_bofa_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            category=category,
            area=area,
            grade=grade,
            options=options,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectICEBofA",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_corporate_ice_bofa_serialize(
        self,
        provider,
        start_date,
        end_date,
        index_type,
        category,
        area,
        grade,
        options,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if index_type is not None:
            
            _query_params.append(('index_type', index_type))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        if area is not None:
            
            _query_params.append(('area', area))
            
        if grade is not None:
            
            _query_params.append(('grade', grade))
            
        if options is not None:
            
            _query_params.append(('options', options))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/corporate/ice_bofa',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_corporate_moody(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series.")] = None,
        spread: Annotated[Optional[StrictStr], Field(description="The type of spread. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectMoodyCorporateBondIndex:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/bond_indices` instead. Set `category` to `us` and `index` to `seasoned_corporate`. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        Moody Corporate Bond Index.  Moody's Aaa and Baa are investment bonds that acts as an index of the performance of all bonds given an Aaa or Baa rating by Moody's Investors Service respectively. These corporate bonds often are used in macroeconomics as an alternative to the federal ten-year Treasury Bill as an indicator of the interest rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series.
        :type index_type: str
        :param spread: The type of spread. (provider: fred)
        :type spread: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/corporate/moody is deprecated.", DeprecationWarning)

        _param = self._fixedincome_corporate_moody_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            spread=spread,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMoodyCorporateBondIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_corporate_moody_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series.")] = None,
        spread: Annotated[Optional[StrictStr], Field(description="The type of spread. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectMoodyCorporateBondIndex]:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/bond_indices` instead. Set `category` to `us` and `index` to `seasoned_corporate`. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        Moody Corporate Bond Index.  Moody's Aaa and Baa are investment bonds that acts as an index of the performance of all bonds given an Aaa or Baa rating by Moody's Investors Service respectively. These corporate bonds often are used in macroeconomics as an alternative to the federal ten-year Treasury Bill as an indicator of the interest rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series.
        :type index_type: str
        :param spread: The type of spread. (provider: fred)
        :type spread: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/corporate/moody is deprecated.", DeprecationWarning)

        _param = self._fixedincome_corporate_moody_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            spread=spread,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMoodyCorporateBondIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_corporate_moody_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index_type: Annotated[Optional[StrictStr], Field(description="The type of series.")] = None,
        spread: Annotated[Optional[StrictStr], Field(description="The type of spread. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/bond_indices` instead. Set `category` to `us` and `index` to `seasoned_corporate`. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        Moody Corporate Bond Index.  Moody's Aaa and Baa are investment bonds that acts as an index of the performance of all bonds given an Aaa or Baa rating by Moody's Investors Service respectively. These corporate bonds often are used in macroeconomics as an alternative to the federal ten-year Treasury Bill as an indicator of the interest rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index_type: The type of series.
        :type index_type: str
        :param spread: The type of spread. (provider: fred)
        :type spread: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/corporate/moody is deprecated.", DeprecationWarning)

        _param = self._fixedincome_corporate_moody_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index_type=index_type,
            spread=spread,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMoodyCorporateBondIndex",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_corporate_moody_serialize(
        self,
        provider,
        start_date,
        end_date,
        index_type,
        spread,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if index_type is not None:
            
            _query_params.append(('index_type', index_type))
            
        if spread is not None:
            
            _query_params.append(('spread', spread))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/corporate/moody',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_corporate_spot_rates(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="Maturities in years. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Rate category. Options: spot_rate, par_yield. Multiple comma separated items allowed for provider(s): fred.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSpotRate:
        """Spot Rates

        Spot Rates.  The spot rates for any maturity is the yield on a bond that provides a single payment at that maturity. This is a zero coupon bond. Because each spot rate pertains to a single cashflow, it is the relevant interest rate concept for discounting a pension liability at the same maturity.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: Maturities in years. Multiple comma separated items allowed for provider(s): fred.
        :type maturity: Maturity
        :param category: Rate category. Options: spot_rate, par_yield. Multiple comma separated items allowed for provider(s): fred.
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_spot_rates_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSpotRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_corporate_spot_rates_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="Maturities in years. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Rate category. Options: spot_rate, par_yield. Multiple comma separated items allowed for provider(s): fred.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSpotRate]:
        """Spot Rates

        Spot Rates.  The spot rates for any maturity is the yield on a bond that provides a single payment at that maturity. This is a zero coupon bond. Because each spot rate pertains to a single cashflow, it is the relevant interest rate concept for discounting a pension liability at the same maturity.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: Maturities in years. Multiple comma separated items allowed for provider(s): fred.
        :type maturity: Maturity
        :param category: Rate category. Options: spot_rate, par_yield. Multiple comma separated items allowed for provider(s): fred.
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_spot_rates_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSpotRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_corporate_spot_rates_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="Maturities in years. Multiple comma separated items allowed for provider(s): fred.")] = None,
        category: Annotated[Optional[StrictStr], Field(description="Rate category. Options: spot_rate, par_yield. Multiple comma separated items allowed for provider(s): fred.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Spot Rates

        Spot Rates.  The spot rates for any maturity is the yield on a bond that provides a single payment at that maturity. This is a zero coupon bond. Because each spot rate pertains to a single cashflow, it is the relevant interest rate concept for discounting a pension liability at the same maturity.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: Maturities in years. Multiple comma separated items allowed for provider(s): fred.
        :type maturity: Maturity
        :param category: Rate category. Options: spot_rate, par_yield. Multiple comma separated items allowed for provider(s): fred.
        :type category: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_corporate_spot_rates_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            category=category,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSpotRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_corporate_spot_rates_serialize(
        self,
        provider,
        start_date,
        end_date,
        maturity,
        category,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if maturity is not None:
            
            _query_params.append(('maturity', maturity))
            
        if category is not None:
            
            _query_params.append(('category', category))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/corporate/spot_rates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_government_tips_yields(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictInt], Field(description="The maturity of the security in years - 5, 10, 20, 30 - defaults to all. Note that the maturity is the tenor of the security, not the time to maturity. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectTipsYields:
        """Tips Yields

        Get current Treasury inflation-protected securities yields.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity of the security in years - 5, 10, 20, 30 - defaults to all. Note that the maturity is the tenor of the security, not the time to maturity. (provider: fred)
        :type maturity: int
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_tips_yields_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTipsYields",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_government_tips_yields_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictInt], Field(description="The maturity of the security in years - 5, 10, 20, 30 - defaults to all. Note that the maturity is the tenor of the security, not the time to maturity. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectTipsYields]:
        """Tips Yields

        Get current Treasury inflation-protected securities yields.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity of the security in years - 5, 10, 20, 30 - defaults to all. Note that the maturity is the tenor of the security, not the time to maturity. (provider: fred)
        :type maturity: int
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_tips_yields_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTipsYields",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_government_tips_yields_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictInt], Field(description="The maturity of the security in years - 5, 10, 20, 30 - defaults to all. Note that the maturity is the tenor of the security, not the time to maturity. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert high frequency data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Tips Yields

        Get current Treasury inflation-protected securities yields.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity of the security in years - 5, 10, 20, 30 - defaults to all. Note that the maturity is the tenor of the security, not the time to maturity. (provider: fred)
        :type maturity: int
        :param frequency: Frequency aggregation to convert high frequency data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_tips_yields_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTipsYields",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_government_tips_yields_serialize(
        self,
        provider,
        start_date,
        end_date,
        maturity,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if maturity is not None:
            
            _query_params.append(('maturity', maturity))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/government/tips_yields',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_government_treasury_rates(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectTreasuryRates:
        """Treasury Rates

        Government Treasury Rates.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_treasury_rates_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTreasuryRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_government_treasury_rates_with_http_info(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectTreasuryRates]:
        """Treasury Rates

        Government Treasury Rates.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_treasury_rates_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTreasuryRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_government_treasury_rates_without_preload_content(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Treasury Rates

        Government Treasury Rates.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_treasury_rates_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTreasuryRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_government_treasury_rates_serialize(
        self,
        provider,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/government/treasury_rates',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_government_us_yield_curve(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[date], Field(description="A specific date to get data for. Defaults to the most recent FRED entry.")] = None,
        inflation_adjusted: Annotated[Optional[StrictBool], Field(description="Get inflation adjusted rates.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectUSYieldCurve:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/fixedincome/government/yield_curve`, instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.4.

        US Yield Curve. Get United States yield curve.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Defaults to the most recent FRED entry.
        :type var_date: date
        :param inflation_adjusted: Get inflation adjusted rates.
        :type inflation_adjusted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/government/us_yield_curve is deprecated.", DeprecationWarning)

        _param = self._fixedincome_government_us_yield_curve_serialize(
            provider=provider,
            var_date=var_date,
            inflation_adjusted=inflation_adjusted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUSYieldCurve",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_government_us_yield_curve_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[date], Field(description="A specific date to get data for. Defaults to the most recent FRED entry.")] = None,
        inflation_adjusted: Annotated[Optional[StrictBool], Field(description="Get inflation adjusted rates.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectUSYieldCurve]:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/fixedincome/government/yield_curve`, instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.4.

        US Yield Curve. Get United States yield curve.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Defaults to the most recent FRED entry.
        :type var_date: date
        :param inflation_adjusted: Get inflation adjusted rates.
        :type inflation_adjusted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/government/us_yield_curve is deprecated.", DeprecationWarning)

        _param = self._fixedincome_government_us_yield_curve_serialize(
            provider=provider,
            var_date=var_date,
            inflation_adjusted=inflation_adjusted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUSYieldCurve",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_government_us_yield_curve_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        var_date: Annotated[Optional[date], Field(description="A specific date to get data for. Defaults to the most recent FRED entry.")] = None,
        inflation_adjusted: Annotated[Optional[StrictBool], Field(description="Get inflation adjusted rates.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) This endpoint will be removed in a future version. Use, `/fixedincome/government/yield_curve`, instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.4.

        US Yield Curve. Get United States yield curve.

        :param provider:
        :type provider: str
        :param var_date: A specific date to get data for. Defaults to the most recent FRED entry.
        :type var_date: date
        :param inflation_adjusted: Get inflation adjusted rates.
        :type inflation_adjusted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/government/us_yield_curve is deprecated.", DeprecationWarning)

        _param = self._fixedincome_government_us_yield_curve_serialize(
            provider=provider,
            var_date=var_date,
            inflation_adjusted=inflation_adjusted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectUSYieldCurve",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_government_us_yield_curve_serialize(
        self,
        provider,
        var_date,
        inflation_adjusted,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if var_date is not None:
            if isinstance(var_date, date):
                _query_params.append(
                    (
                        'date',
                        var_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('date', var_date))
            
        if inflation_adjusted is not None:
            
            _query_params.append(('inflation_adjusted', inflation_adjusted))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/government/us_yield_curve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_government_yield_curve(
        self,
        provider: StrictStr,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. By default is the current data. Multiple comma separated items allowed for provider(s): econdb, federal_reserve, fmp, fred.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. New Zealand, Mexico, Singapore, and Thailand have only monthly data. The nearest date to the requested one will be used. Multiple comma separated items allowed. (provider: econdb)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If true, cache the request for four hours. (provider: econdb)")] = None,
        yield_curve_type: Annotated[Optional[StrictStr], Field(description="Yield curve type. Nominal and Real Rates are available daily, others are monthly. The closest date to the requested date will be returned. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectYieldCurve:
        """Yield Curve

        Get yield curve data by country and date.

        :param provider: (required)
        :type provider: str
        :param var_date: A specific date to get data for. By default is the current data. Multiple comma separated items allowed for provider(s): econdb, federal_reserve, fmp, fred.
        :type var_date: Date4
        :param country: The country to get data. New Zealand, Mexico, Singapore, and Thailand have only monthly data. The nearest date to the requested one will be used. Multiple comma separated items allowed. (provider: econdb)
        :type country: str
        :param use_cache: If true, cache the request for four hours. (provider: econdb)
        :type use_cache: bool
        :param yield_curve_type: Yield curve type. Nominal and Real Rates are available daily, others are monthly. The closest date to the requested date will be returned. (provider: fred)
        :type yield_curve_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_yield_curve_serialize(
            provider=provider,
            var_date=var_date,
            country=country,
            use_cache=use_cache,
            yield_curve_type=yield_curve_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectYieldCurve",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_government_yield_curve_with_http_info(
        self,
        provider: StrictStr,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. By default is the current data. Multiple comma separated items allowed for provider(s): econdb, federal_reserve, fmp, fred.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. New Zealand, Mexico, Singapore, and Thailand have only monthly data. The nearest date to the requested one will be used. Multiple comma separated items allowed. (provider: econdb)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If true, cache the request for four hours. (provider: econdb)")] = None,
        yield_curve_type: Annotated[Optional[StrictStr], Field(description="Yield curve type. Nominal and Real Rates are available daily, others are monthly. The closest date to the requested date will be returned. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectYieldCurve]:
        """Yield Curve

        Get yield curve data by country and date.

        :param provider: (required)
        :type provider: str
        :param var_date: A specific date to get data for. By default is the current data. Multiple comma separated items allowed for provider(s): econdb, federal_reserve, fmp, fred.
        :type var_date: Date4
        :param country: The country to get data. New Zealand, Mexico, Singapore, and Thailand have only monthly data. The nearest date to the requested one will be used. Multiple comma separated items allowed. (provider: econdb)
        :type country: str
        :param use_cache: If true, cache the request for four hours. (provider: econdb)
        :type use_cache: bool
        :param yield_curve_type: Yield curve type. Nominal and Real Rates are available daily, others are monthly. The closest date to the requested date will be returned. (provider: fred)
        :type yield_curve_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_yield_curve_serialize(
            provider=provider,
            var_date=var_date,
            country=country,
            use_cache=use_cache,
            yield_curve_type=yield_curve_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectYieldCurve",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_government_yield_curve_without_preload_content(
        self,
        provider: StrictStr,
        var_date: Annotated[Optional[Any], Field(description="A specific date to get data for. By default is the current data. Multiple comma separated items allowed for provider(s): econdb, federal_reserve, fmp, fred.")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to get data. New Zealand, Mexico, Singapore, and Thailand have only monthly data. The nearest date to the requested one will be used. Multiple comma separated items allowed. (provider: econdb)")] = None,
        use_cache: Annotated[Optional[StrictBool], Field(description="If true, cache the request for four hours. (provider: econdb)")] = None,
        yield_curve_type: Annotated[Optional[StrictStr], Field(description="Yield curve type. Nominal and Real Rates are available daily, others are monthly. The closest date to the requested date will be returned. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Yield Curve

        Get yield curve data by country and date.

        :param provider: (required)
        :type provider: str
        :param var_date: A specific date to get data for. By default is the current data. Multiple comma separated items allowed for provider(s): econdb, federal_reserve, fmp, fred.
        :type var_date: Date4
        :param country: The country to get data. New Zealand, Mexico, Singapore, and Thailand have only monthly data. The nearest date to the requested one will be used. Multiple comma separated items allowed. (provider: econdb)
        :type country: str
        :param use_cache: If true, cache the request for four hours. (provider: econdb)
        :type use_cache: bool
        :param yield_curve_type: Yield curve type. Nominal and Real Rates are available daily, others are monthly. The closest date to the requested date will be returned. (provider: fred)
        :type yield_curve_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_government_yield_curve_serialize(
            provider=provider,
            var_date=var_date,
            country=country,
            use_cache=use_cache,
            yield_curve_type=yield_curve_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectYieldCurve",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_government_yield_curve_serialize(
        self,
        provider,
        var_date,
        country,
        use_cache,
        yield_curve_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if var_date is not None:
            
            _query_params.append(('date', var_date))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if use_cache is not None:
            
            _query_params.append(('use_cache', use_cache))
            
        if yield_curve_type is not None:
            
            _query_params.append(('yield_curve_type', yield_curve_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/government/yield_curve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_mortgage_indices(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index: Annotated[Optional[Any], Field(description="The specific index, or index group, to query. Default is the 'primary' group. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectMortgageIndices:
        """Mortgage Indices

        Mortgage Indices.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index: The specific index, or index group, to query. Default is the 'primary' group. Multiple comma separated items allowed. (provider: fred)
        :type index: Fred4
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_mortgage_indices_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index=index,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMortgageIndices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_mortgage_indices_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index: Annotated[Optional[Any], Field(description="The specific index, or index group, to query. Default is the 'primary' group. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectMortgageIndices]:
        """Mortgage Indices

        Mortgage Indices.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index: The specific index, or index group, to query. Default is the 'primary' group. Multiple comma separated items allowed. (provider: fred)
        :type index: Fred4
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_mortgage_indices_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index=index,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMortgageIndices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_mortgage_indices_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        index: Annotated[Optional[Any], Field(description="The specific index, or index group, to query. Default is the 'primary' group. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Mortgage Indices

        Mortgage Indices.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param index: The specific index, or index group, to query. Default is the 'primary' group. Multiple comma separated items allowed. (provider: fred)
        :type index: Fred4
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             None = No change             a = Annual             q = Quarterly             m = Monthly             w = Weekly             d = Daily             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.         This parameter has no affect if the frequency parameter is not set, default is 'avg'.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_mortgage_indices_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            index=index,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectMortgageIndices",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_mortgage_indices_serialize(
        self,
        provider,
        start_date,
        end_date,
        index,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if index is not None:
            
            _query_params.append(('index', index))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/mortgage_indices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_ameribor(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="Period of AMERIBOR rate. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectAmeribor:
        """Ameribor

        AMERIBOR.  AMERIBOR (short for the American interbank offered rate) is a benchmark interest rate that reflects the true cost of short-term interbank borrowing. This rate is based on transactions in overnight unsecured loans conducted on the American Financial Exchange (AFX).

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: Period of AMERIBOR rate. Multiple comma separated items allowed. (provider: fred)
        :type maturity: Fred1
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_ameribor_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectAmeribor",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_ameribor_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="Period of AMERIBOR rate. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectAmeribor]:
        """Ameribor

        AMERIBOR.  AMERIBOR (short for the American interbank offered rate) is a benchmark interest rate that reflects the true cost of short-term interbank borrowing. This rate is based on transactions in overnight unsecured loans conducted on the American Financial Exchange (AFX).

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: Period of AMERIBOR rate. Multiple comma separated items allowed. (provider: fred)
        :type maturity: Fred1
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_ameribor_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectAmeribor",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_ameribor_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[Any], Field(description="Period of AMERIBOR rate. Multiple comma separated items allowed. (provider: fred)")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ameribor

        AMERIBOR.  AMERIBOR (short for the American interbank offered rate) is a benchmark interest rate that reflects the true cost of short-term interbank borrowing. This rate is based on transactions in overnight unsecured loans conducted on the American Financial Exchange (AFX).

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: Period of AMERIBOR rate. Multiple comma separated items allowed. (provider: fred)
        :type maturity: Fred1
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_ameribor_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectAmeribor",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_ameribor_serialize(
        self,
        provider,
        start_date,
        end_date,
        maturity,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if maturity is not None:
            
            _query_params.append(('maturity', maturity))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/ameribor',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_dpcredit(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        parameter: Annotated[Optional[StrictStr], Field(description="FRED series ID of DWPCR data. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectDiscountWindowPrimaryCreditRate:
        """Dpcredit

        Discount Window Primary Credit Rate.  A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy. In the United States, the Federal Reserve System's Board of Governors set the bank rate, also known as the discount rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param parameter: FRED series ID of DWPCR data. (provider: fred)
        :type parameter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_dpcredit_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectDiscountWindowPrimaryCreditRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_dpcredit_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        parameter: Annotated[Optional[StrictStr], Field(description="FRED series ID of DWPCR data. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectDiscountWindowPrimaryCreditRate]:
        """Dpcredit

        Discount Window Primary Credit Rate.  A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy. In the United States, the Federal Reserve System's Board of Governors set the bank rate, also known as the discount rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param parameter: FRED series ID of DWPCR data. (provider: fred)
        :type parameter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_dpcredit_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectDiscountWindowPrimaryCreditRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_dpcredit_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        parameter: Annotated[Optional[StrictStr], Field(description="FRED series ID of DWPCR data. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Dpcredit

        Discount Window Primary Credit Rate.  A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy. In the United States, the Federal Reserve System's Board of Governors set the bank rate, also known as the discount rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param parameter: FRED series ID of DWPCR data. (provider: fred)
        :type parameter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_dpcredit_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectDiscountWindowPrimaryCreditRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_dpcredit_serialize(
        self,
        provider,
        start_date,
        end_date,
        parameter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if parameter is not None:
            
            _query_params.append(('parameter', parameter))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/dpcredit',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_ecb(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        interest_rate_type: Annotated[Optional[StrictStr], Field(description="The type of interest rate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectEuropeanCentralBankInterestRates:
        """Ecb

        European Central Bank Interest Rates.  The Governing Council of the ECB sets the key interest rates for the euro area:  - The interest rate on the main refinancing operations (MRO), which provide the bulk of liquidity to the banking system. - The rate on the deposit facility, which banks may use to make overnight deposits with the Eurosystem. - The rate on the marginal lending facility, which offers overnight credit to banks from the Eurosystem.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param interest_rate_type: The type of interest rate.
        :type interest_rate_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_ecb_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            interest_rate_type=interest_rate_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEuropeanCentralBankInterestRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_ecb_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        interest_rate_type: Annotated[Optional[StrictStr], Field(description="The type of interest rate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectEuropeanCentralBankInterestRates]:
        """Ecb

        European Central Bank Interest Rates.  The Governing Council of the ECB sets the key interest rates for the euro area:  - The interest rate on the main refinancing operations (MRO), which provide the bulk of liquidity to the banking system. - The rate on the deposit facility, which banks may use to make overnight deposits with the Eurosystem. - The rate on the marginal lending facility, which offers overnight credit to banks from the Eurosystem.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param interest_rate_type: The type of interest rate.
        :type interest_rate_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_ecb_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            interest_rate_type=interest_rate_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEuropeanCentralBankInterestRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_ecb_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        interest_rate_type: Annotated[Optional[StrictStr], Field(description="The type of interest rate.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Ecb

        European Central Bank Interest Rates.  The Governing Council of the ECB sets the key interest rates for the euro area:  - The interest rate on the main refinancing operations (MRO), which provide the bulk of liquidity to the banking system. - The rate on the deposit facility, which banks may use to make overnight deposits with the Eurosystem. - The rate on the marginal lending facility, which offers overnight credit to banks from the Eurosystem.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param interest_rate_type: The type of interest rate.
        :type interest_rate_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_ecb_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            interest_rate_type=interest_rate_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEuropeanCentralBankInterestRates",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_ecb_serialize(
        self,
        provider,
        start_date,
        end_date,
        interest_rate_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if interest_rate_type is not None:
            
            _query_params.append(('interest_rate_type', interest_rate_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/ecb',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_effr(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        effr_only: Annotated[Optional[StrictBool], Field(description="Return data without quantiles, target ranges, and volume. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectFederalFundsRate:
        """Effr

        Fed Funds Rate.  Get Effective Federal Funds Rate data. A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param effr_only: Return data without quantiles, target ranges, and volume. (provider: fred)
        :type effr_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            effr_only=effr_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFederalFundsRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_effr_with_http_info(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        effr_only: Annotated[Optional[StrictBool], Field(description="Return data without quantiles, target ranges, and volume. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectFederalFundsRate]:
        """Effr

        Fed Funds Rate.  Get Effective Federal Funds Rate data. A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param effr_only: Return data without quantiles, target ranges, and volume. (provider: fred)
        :type effr_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            effr_only=effr_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFederalFundsRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_effr_without_preload_content(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        effr_only: Annotated[Optional[StrictBool], Field(description="Return data without quantiles, target ranges, and volume. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Effr

        Fed Funds Rate.  Get Effective Federal Funds Rate data. A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param effr_only: Return data without quantiles, target ranges, and volume. (provider: fred)
        :type effr_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            effr_only=effr_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectFederalFundsRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_effr_serialize(
        self,
        provider,
        start_date,
        end_date,
        frequency,
        aggregation_method,
        transform,
        effr_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        if effr_only is not None:
            
            _query_params.append(('effr_only', effr_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/effr',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_effr_forecast(
        self,
        provider: Optional[StrictStr] = None,
        long_run: Annotated[Optional[StrictBool], Field(description="Flag to show long run projections (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectPROJECTIONS:
        """Effr Forecast

        Fed Funds Rate Projections.  The projections for the federal funds rate are the value of the midpoint of the projected appropriate target range for the federal funds rate or the projected appropriate target level for the federal funds rate at the end of the specified calendar year or over the longer run.

        :param provider:
        :type provider: str
        :param long_run: Flag to show long run projections (provider: fred)
        :type long_run: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_effr_forecast_serialize(
            provider=provider,
            long_run=long_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPROJECTIONS",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_effr_forecast_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        long_run: Annotated[Optional[StrictBool], Field(description="Flag to show long run projections (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectPROJECTIONS]:
        """Effr Forecast

        Fed Funds Rate Projections.  The projections for the federal funds rate are the value of the midpoint of the projected appropriate target range for the federal funds rate or the projected appropriate target level for the federal funds rate at the end of the specified calendar year or over the longer run.

        :param provider:
        :type provider: str
        :param long_run: Flag to show long run projections (provider: fred)
        :type long_run: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_effr_forecast_serialize(
            provider=provider,
            long_run=long_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPROJECTIONS",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_effr_forecast_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        long_run: Annotated[Optional[StrictBool], Field(description="Flag to show long run projections (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Effr Forecast

        Fed Funds Rate Projections.  The projections for the federal funds rate are the value of the midpoint of the projected appropriate target range for the federal funds rate or the projected appropriate target level for the federal funds rate at the end of the specified calendar year or over the longer run.

        :param provider:
        :type provider: str
        :param long_run: Flag to show long run projections (provider: fred)
        :type long_run: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_effr_forecast_serialize(
            provider=provider,
            long_run=long_run,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectPROJECTIONS",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_effr_forecast_serialize(
        self,
        provider,
        long_run,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if long_run is not None:
            
            _query_params.append(('long_run', long_run))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/effr_forecast',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_estr(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert daily data to lower frequency.              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectEuroShortTermRate:
        """Estr

        Euro Short-Term Rate.  The euro short-term rate (STR) reflects the wholesale euro unsecured overnight borrowing costs of banks located in the euro area. The STR is published on each TARGET2 business day based on transactions conducted and settled on the previous TARGET2 business day (the reporting date T) with a maturity date of T+1 which are deemed to have been executed at arm's length and thus reflect market rates in an unbiased way.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert daily data to lower frequency.              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_estr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEuroShortTermRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_estr_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert daily data to lower frequency.              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectEuroShortTermRate]:
        """Estr

        Euro Short-Term Rate.  The euro short-term rate (STR) reflects the wholesale euro unsecured overnight borrowing costs of banks located in the euro area. The STR is published on each TARGET2 business day based on transactions conducted and settled on the previous TARGET2 business day (the reporting date T) with a maturity date of T+1 which are deemed to have been executed at arm's length and thus reflect market rates in an unbiased way.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert daily data to lower frequency.              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_estr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEuroShortTermRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_estr_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="Frequency aggregation to convert daily data to lower frequency.              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Estr

        Euro Short-Term Rate.  The euro short-term rate (STR) reflects the wholesale euro unsecured overnight borrowing costs of banks located in the euro area. The STR is published on each TARGET2 business day based on transactions conducted and settled on the previous TARGET2 business day (the reporting date T) with a maturity date of T+1 which are deemed to have been executed at arm's length and thus reflect market rates in an unbiased way.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency: Frequency aggregation to convert daily data to lower frequency.              a = Annual              q = Quarterly              m = Monthly              w = Weekly              d = Daily              wef = Weekly, Ending Friday              weth = Weekly, Ending Thursday              wew = Weekly, Ending Wednesday              wetu = Weekly, Ending Tuesday              wem = Weekly, Ending Monday              wesu = Weekly, Ending Sunday              wesa = Weekly, Ending Saturday              bwew = Biweekly, Ending Wednesday              bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method: A key that indicates the aggregation method used for frequency aggregation.              avg = Average              sum = Sum              eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform: Transformation type              None = No transformation              chg = Change              ch1 = Change from Year Ago              pch = Percent Change              pc1 = Percent Change from Year Ago              pca = Compounded Annual Rate of Change              cch = Continuously Compounded Rate of Change              cca = Continuously Compounded Annual Rate of Change              log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_estr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectEuroShortTermRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_estr_serialize(
        self,
        provider,
        start_date,
        end_date,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/estr',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_iorb(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectIORB:
        """Iorb

        Interest on Reserve Balances.  Get Interest Rate on Reserve Balances data A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy. In the United States, the Federal Reserve System's Board of Governors set the bank rate, also known as the discount rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_iorb_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectIORB",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_iorb_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectIORB]:
        """Iorb

        Interest on Reserve Balances.  Get Interest Rate on Reserve Balances data A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy. In the United States, the Federal Reserve System's Board of Governors set the bank rate, also known as the discount rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_iorb_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectIORB",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_iorb_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Iorb

        Interest on Reserve Balances.  Get Interest Rate on Reserve Balances data A bank rate is the interest rate a nation's central bank charges to its domestic banks to borrow money. The rates central banks charge are set to stabilize the economy. In the United States, the Federal Reserve System's Board of Governors set the bank rate, also known as the discount rate.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_iorb_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectIORB",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_iorb_serialize(
        self,
        provider,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/iorb',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_overnight_bank_funding(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectOvernightBankFundingRate:
        """Overnight Bank Funding

        Overnight Bank Funding.  For the United States, the overnight bank funding rate (OBFR) is calculated as a volume-weighted median of overnight federal funds transactions and Eurodollar transactions reported in the FR 2420 Report of Selected Money Market Rates.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_overnight_bank_funding_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectOvernightBankFundingRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_overnight_bank_funding_with_http_info(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectOvernightBankFundingRate]:
        """Overnight Bank Funding

        Overnight Bank Funding.  For the United States, the overnight bank funding rate (OBFR) is calculated as a volume-weighted median of overnight federal funds transactions and Eurodollar transactions reported in the FR 2420 Report of Selected Money Market Rates.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_overnight_bank_funding_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectOvernightBankFundingRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_overnight_bank_funding_without_preload_content(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Overnight Bank Funding

        Overnight Bank Funding.  For the United States, the overnight bank funding rate (OBFR) is calculated as a volume-weighted median of overnight federal funds transactions and Eurodollar transactions reported in the FR 2420 Report of Selected Money Market Rates.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_overnight_bank_funding_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectOvernightBankFundingRate",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_overnight_bank_funding_serialize(
        self,
        provider,
        start_date,
        end_date,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/overnight_bank_funding',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_sofr(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSOFR:
        """Sofr

        Secured Overnight Financing Rate.  The Secured Overnight Financing Rate (SOFR) is a broad measure of the cost of borrowing cash overnight collateralizing by Treasury securities.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_sofr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSOFR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_sofr_with_http_info(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSOFR]:
        """Sofr

        Secured Overnight Financing Rate.  The Secured Overnight Financing Rate (SOFR) is a broad measure of the cost of borrowing cash overnight collateralizing by Treasury securities.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_sofr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSOFR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_sofr_without_preload_content(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sofr

        Secured Overnight Financing Rate.  The Secured Overnight Financing Rate (SOFR) is a broad measure of the cost of borrowing cash overnight collateralizing by Treasury securities.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_sofr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSOFR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_sofr_serialize(
        self,
        provider,
        start_date,
        end_date,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/sofr',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_rate_sonia(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        parameter: Annotated[Optional[StrictStr], Field(description="Period of SONIA rate. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSONIA:
        """Sonia

        Sterling Overnight Index Average.  SONIA (Sterling Overnight Index Average) is an important interest rate benchmark. SONIA is based on actual transactions and reflects the average of the interest rates that banks pay to borrow sterling overnight from other financial institutions and other institutional investors.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param parameter: Period of SONIA rate. (provider: fred)
        :type parameter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_sonia_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSONIA",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_rate_sonia_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        parameter: Annotated[Optional[StrictStr], Field(description="Period of SONIA rate. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSONIA]:
        """Sonia

        Sterling Overnight Index Average.  SONIA (Sterling Overnight Index Average) is an important interest rate benchmark. SONIA is based on actual transactions and reflects the average of the interest rates that banks pay to borrow sterling overnight from other financial institutions and other institutional investors.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param parameter: Period of SONIA rate. (provider: fred)
        :type parameter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_sonia_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSONIA",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_rate_sonia_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        parameter: Annotated[Optional[StrictStr], Field(description="Period of SONIA rate. (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Sonia

        Sterling Overnight Index Average.  SONIA (Sterling Overnight Index Average) is an important interest rate benchmark. SONIA is based on actual transactions and reflects the average of the interest rates that banks pay to borrow sterling overnight from other financial institutions and other institutional investors.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param parameter: Period of SONIA rate. (provider: fred)
        :type parameter: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_rate_sonia_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            parameter=parameter,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSONIA",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_rate_sonia_serialize(
        self,
        provider,
        start_date,
        end_date,
        parameter,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if parameter is not None:
            
            _query_params.append(('parameter', parameter))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/rate/sonia',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_sofr(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSOFR:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/rate/sofr` instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        Secured Overnight Financing Rate.  The Secured Overnight Financing Rate (SOFR) is a broad measure of the cost of borrowing cash overnight collateralizing by Treasury securities.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/sofr is deprecated.", DeprecationWarning)

        _param = self._fixedincome_sofr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSOFR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_sofr_with_http_info(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSOFR]:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/rate/sofr` instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        Secured Overnight Financing Rate.  The Secured Overnight Financing Rate (SOFR) is a broad measure of the cost of borrowing cash overnight collateralizing by Treasury securities.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/sofr is deprecated.", DeprecationWarning)

        _param = self._fixedincome_sofr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSOFR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_sofr_without_preload_content(
        self,
        provider: StrictStr,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        frequency: Annotated[Optional[StrictStr], Field(description="         Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)")] = None,
        aggregation_method: Annotated[Optional[StrictStr], Field(description="         A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)")] = None,
        transform: Annotated[Optional[StrictStr], Field(description="         Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """(Deprecated) This endpoint is deprecated; use `/fixedincome/rate/sofr` instead. Deprecated in OpenBB Platform V4.2 to be removed in V4.5.

        Secured Overnight Financing Rate.  The Secured Overnight Financing Rate (SOFR) is a broad measure of the cost of borrowing cash overnight collateralizing by Treasury securities.

        :param provider: (required)
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param frequency:          Frequency aggregation to convert daily data to lower frequency.             a = Annual             q = Quarterly             m = Monthly             w = Weekly             wef = Weekly, Ending Friday             weth = Weekly, Ending Thursday             wew = Weekly, Ending Wednesday             wetu = Weekly, Ending Tuesday             wem = Weekly, Ending Monday             wesu = Weekly, Ending Sunday             wesa = Weekly, Ending Saturday             bwew = Biweekly, Ending Wednesday             bwem = Biweekly, Ending Monday          (provider: fred)
        :type frequency: str
        :param aggregation_method:          A key that indicates the aggregation method used for frequency aggregation.             avg = Average             sum = Sum             eop = End of Period          (provider: fred)
        :type aggregation_method: str
        :param transform:          Transformation type             None = No transformation             chg = Change             ch1 = Change from Year Ago             pch = Percent Change             pc1 = Percent Change from Year Ago             pca = Compounded Annual Rate of Change             cch = Continuously Compounded Rate of Change             cca = Continuously Compounded Annual Rate of Change             log = Natural Log          (provider: fred)
        :type transform: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501
        warnings.warn("GET /api/v1/fixedincome/sofr is deprecated.", DeprecationWarning)

        _param = self._fixedincome_sofr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            frequency=frequency,
            aggregation_method=aggregation_method,
            transform=transform,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSOFR",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_sofr_serialize(
        self,
        provider,
        start_date,
        end_date,
        frequency,
        aggregation_method,
        transform,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if frequency is not None:
            
            _query_params.append(('frequency', frequency))
            
        if aggregation_method is not None:
            
            _query_params.append(('aggregation_method', aggregation_method))
            
        if transform is not None:
            
            _query_params.append(('transform', transform))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/sofr',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_spreads_tcm(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectTreasuryConstantMaturity:
        """Tcm

        Treasury Constant Maturity.  Get data for 10-Year Treasury Constant Maturity Minus Selected Treasury Constant Maturity. Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_tcm_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTreasuryConstantMaturity",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_spreads_tcm_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectTreasuryConstantMaturity]:
        """Tcm

        Treasury Constant Maturity.  Get data for 10-Year Treasury Constant Maturity Minus Selected Treasury Constant Maturity. Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_tcm_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTreasuryConstantMaturity",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_spreads_tcm_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Tcm

        Treasury Constant Maturity.  Get data for 10-Year Treasury Constant Maturity Minus Selected Treasury Constant Maturity. Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_tcm_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectTreasuryConstantMaturity",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_spreads_tcm_serialize(
        self,
        provider,
        start_date,
        end_date,
        maturity,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if maturity is not None:
            
            _query_params.append(('maturity', maturity))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/spreads/tcm',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_spreads_tcm_effr(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSelectedTreasuryConstantMaturity:
        """Tcm Effr

        Select Treasury Constant Maturity.  Get data for Selected Treasury Constant Maturity Minus Federal Funds Rate Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_tcm_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSelectedTreasuryConstantMaturity",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_spreads_tcm_effr_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSelectedTreasuryConstantMaturity]:
        """Tcm Effr

        Select Treasury Constant Maturity.  Get data for Selected Treasury Constant Maturity Minus Federal Funds Rate Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_tcm_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSelectedTreasuryConstantMaturity",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_spreads_tcm_effr_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Tcm Effr

        Select Treasury Constant Maturity.  Get data for Selected Treasury Constant Maturity Minus Federal Funds Rate Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_tcm_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSelectedTreasuryConstantMaturity",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_spreads_tcm_effr_serialize(
        self,
        provider,
        start_date,
        end_date,
        maturity,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if maturity is not None:
            
            _query_params.append(('maturity', maturity))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/spreads/tcm_effr',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def fixedincome_spreads_treasury_effr(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OBBjectSelectedTreasuryBill:
        """Treasury Effr

        Select Treasury Bill.  Get Selected Treasury Bill Minus Federal Funds Rate. Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_treasury_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSelectedTreasuryBill",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def fixedincome_spreads_treasury_effr_with_http_info(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OBBjectSelectedTreasuryBill]:
        """Treasury Effr

        Select Treasury Bill.  Get Selected Treasury Bill Minus Federal Funds Rate. Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_treasury_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSelectedTreasuryBill",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def fixedincome_spreads_treasury_effr_without_preload_content(
        self,
        provider: Optional[StrictStr] = None,
        start_date: Annotated[Optional[date], Field(description="Start date of the data, in YYYY-MM-DD format.")] = None,
        end_date: Annotated[Optional[date], Field(description="End date of the data, in YYYY-MM-DD format.")] = None,
        maturity: Annotated[Optional[StrictStr], Field(description="The maturity")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Treasury Effr

        Select Treasury Bill.  Get Selected Treasury Bill Minus Federal Funds Rate. Constant maturity is the theoretical value of a U.S. Treasury that is based on recent values of auctioned U.S. Treasuries. The value is obtained by the U.S. Treasury on a daily basis through interpolation of the Treasury yield curve which, in turn, is based on closing bid-yields of actively-traded Treasury securities.

        :param provider:
        :type provider: str
        :param start_date: Start date of the data, in YYYY-MM-DD format.
        :type start_date: date
        :param end_date: End date of the data, in YYYY-MM-DD format.
        :type end_date: date
        :param maturity: The maturity
        :type maturity: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._fixedincome_spreads_treasury_effr_serialize(
            provider=provider,
            start_date=start_date,
            end_date=end_date,
            maturity=maturity,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OBBjectSelectedTreasuryBill",
            '404': None,
            '204': None,
            '400': "OpenBBErrorResponse",
            '500': "OpenBBErrorResponse",
            '502': "OpenBBErrorResponse",
            '422': "HTTPValidationError",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _fixedincome_spreads_treasury_effr_serialize(
        self,
        provider,
        start_date,
        end_date,
        maturity,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if provider is not None:
            
            _query_params.append(('provider', provider))
            
        if start_date is not None:
            if isinstance(start_date, date):
                _query_params.append(
                    (
                        'start_date',
                        start_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('start_date', start_date))
            
        if end_date is not None:
            if isinstance(end_date, date):
                _query_params.append(
                    (
                        'end_date',
                        end_date.strftime(
                            self.api_client.configuration.date_format
                        )
                    )
                )
            else:
                _query_params.append(('end_date', end_date))
            
        if maturity is not None:
            
            _query_params.append(('maturity', maturity))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'application/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v1/fixedincome/spreads/treasury_effr',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


